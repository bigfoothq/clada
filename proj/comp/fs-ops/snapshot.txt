
=== START FILE: ./test/unit/formatNodeError.test.ts ===
import { describe, it, expect } from 'vitest';
import { readFileSync } from 'fs';
import { join } from 'path';
import { formatNodeError } from '../../src/formatNodeError.js';

const testData = JSON.parse(
  readFileSync(join(__dirname, '../../test-data/unit/formatNodeError.cases.json'), 'utf8')
);

describe('formatNodeError', () => {
  testData.cases.forEach(({ name, input, expected }) => {
    it(name, () => {
      const result = formatNodeError(input[0], input[1], input[2], input[3]);
      expect(result).toEqual(expected);
    });
  });
});
=== END FILE: ./test/unit/formatNodeError.test.ts ===

=== START FILE: ./test/unit/replaceText.test.ts ===
import { describe, it, expect } from 'vitest';
import { replaceText } from '../../src/replaceText';
import { cases } from '../../test-data/unit/replaceText.cases';

describe('replaceText', () => {
  cases.forEach(({ name, input, expected, throws }) => {
    it(name, () => {
      if (throws) {
        expect(() => replaceText(...input)).toThrow(throws);
      } else {
        const result = replaceText(...input);
        expect(result).toEqual(expected);
      }
    });
  });
});

=== END FILE: ./test/unit/replaceText.test.ts ===

=== START FILE: ./test/integration/integration.test.ts ===
import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { readFileSync, rmSync, existsSync, writeFileSync, mkdirSync } from 'fs';
import { join } from 'path';
import { marked, Token } from 'marked';
import { parseShamResponse } from '../../../sham-action-parser/src/index.js';
import { executeFileOperation } from '../../src/index.js';

// Read test data
const testPath = join(__dirname, '../../test-data/integration/file-operations.cases.md');
const mdContent = readFileSync(testPath, 'utf8');

// Parse markdown to extract test cases with hierarchy
const tokens: Token[] = marked.lexer(mdContent);

interface TestCase {
  name: string;
  shamBlock: string;
  expectedBlock: string;
}

interface TestGroup {
  name: string;
  tests: TestCase[];
}

// Extract test structure from markdown
const testGroups: TestGroup[] = [];
let currentGroup: TestGroup | null = null;
let currentTest: Partial<TestCase> | null = null;
let codeBlockIndex = 0;

tokens.forEach(token => {
  if (token.type === 'heading' && 'depth' in token) {
    if (token.depth === 2) {
      // New test group (e.g., "file_write")
      currentGroup = {
        name: (token as any).text,
        tests: []
      };
      testGroups.push(currentGroup);
    } else if (token.depth === 3 && currentGroup) {
      // New test case
      currentTest = {
        name: (token as any).text
      };
    }
  } else if (token.type === 'code' && currentTest && currentGroup) {
    const codeBlock = token as Token & {type: 'code', text: string};
    if (!currentTest.shamBlock) {
      currentTest.shamBlock = codeBlock.text;
    } else if (!currentTest.expectedBlock) {
      currentTest.expectedBlock = codeBlock.text;
      // Test case complete
      currentGroup.tests.push(currentTest as TestCase);
      currentTest = null;
    }
  }
});

// Test cleanup paths
const testPaths = [
  '/tmp/test.txt',
  '/tmp/deeply',
  '/tmp/existing.txt',
  '/tmp/multiline.txt',
  '/tmp/to-delete.txt',
  '/tmp/does-not-exist.txt',
  '/tmp/source.txt',
  '/tmp/destination.txt',
  '/tmp/original.txt',
  '/tmp/new-dir',
  '/tmp/ghost.txt',
  '/tmp/nowhere.txt',
  '/tmp/source-exists.txt',
  '/tmp/dest-exists.txt',
  '/tmp/moveable.txt',
  '/tmp/replace-test.txt',
  '/tmp/multi-replace.txt',
  '/tmp/no-match.txt',
  '/tmp/does-not-exist-replace.txt',
  '/tmp/multiline-replace.txt',
  '/tmp/empty-search.txt',
  '/tmp/readable.txt',
  '/tmp/not-there.txt'
];

describe('fs-ops integration tests', () => {
  beforeEach(() => {
    // Clean up any existing test files
    testPaths.forEach(path => {
      if (existsSync(path)) {
        rmSync(path, { recursive: true, force: true });
      }
    });
  });

  afterEach(() => {
    // Clean up after tests
    testPaths.forEach(path => {
      if (existsSync(path)) {
        rmSync(path, { recursive: true, force: true });
      }
    });
  });

  testGroups.forEach(group => {
    describe(group.name, () => {
      group.tests.forEach(test => {
        it(test.name, async () => {
          const expectedOutput = JSON.parse(test.expectedBlock);
          
          // Extract test name without number prefix
          const tn = test.name.replace(/^\d{3}-/, '');
          
          // Set up test preconditions based on group and test name
          if (group.name === 'file_delete' && tn === 'delete-existing-file') {
            // Create file to be deleted
            writeFileSync('/tmp/to-delete.txt', 'This file will be deleted');
          } else if (group.name === 'file_move' && tn === 'move-file-simple') {
            // Create source file to be moved
            writeFileSync('/tmp/source.txt', 'Content to move');
          } else if (group.name === 'file_move' && tn === 'move-file-to-new-directory') {
            // Create file to move to new directory
            writeFileSync('/tmp/original.txt', 'Moving to new directory');
          } else if (group.name === 'file_move' && tn === 'move-to-existing-file') {
            // Create both source and destination files
            writeFileSync('/tmp/source-exists.txt', 'Source content');
            writeFileSync('/tmp/dest-exists.txt', 'Will be overwritten');
          } else if (group.name === 'file_replace_text' && tn === 'simple-text-replacement') {
            // Create file with text to replace
            writeFileSync('/tmp/replace-test.txt', 'Hello World');
          } else if (group.name === 'file_replace_text' && tn === 'replace-with-count-limit') {
            // Create file with multiple occurrences
            writeFileSync('/tmp/multi-replace.txt', 'foo bar foo baz foo qux foo');
          } else if (group.name === 'file_replace_text' && tn === 'replace-text-not-found') {
            // Create file without the search text
            writeFileSync('/tmp/no-match.txt', 'This file has no matches');
          } else if (group.name === 'file_replace_text' && tn === 'multiline-replacement') {
            // Create file with multiline content to replace
            writeFileSync('/tmp/multiline-replace.txt', `export function oldName() {
  console.log('oldName');
  return oldName;
}

function oldName() {
  return oldName;
}

const x = oldName();`);
          } else if (group.name === 'file_replace_text' && tn === 'empty-old-text-error') {
            // Create file for empty search test
            writeFileSync('/tmp/empty-search.txt', 'Some content here');
          } else if (group.name === 'file_read' && tn === 'read-existing-file') {
            // Create file to read
            writeFileSync('/tmp/readable.txt', 'This is readable content');
          }
          
          // Parse SHAM to get actions
          const parseResult = await parseShamResponse(test.shamBlock);
          
          // Should have exactly one action
          expect(parseResult.actions).toHaveLength(1);
          expect(parseResult.errors).toHaveLength(0);
          
          // Execute the action
          const result = await executeFileOperation(parseResult.actions[0]);
          
          // Compare result
          expect(result).toEqual(expectedOutput);
        });
      });
    });
  });
});
=== END FILE: ./test/integration/integration.test.ts ===

=== START FILE: ./test-data/unit/replaceText.cases.ts ===
export const cases = [
  {
    name: "simple replacement",
    input: ["hello world", "world", "universe"],
    expected: {
      result: "hello universe",
      replacements: 1,
    },
  },
  {
    name: "multiple replacements",
    input: ["foo bar foo baz", "foo", "qux"],
    expected: {
      result: "qux bar qux baz",
      replacements: 2,
    },
  },
  {
    name: "limited replacements",
    input: ["foo bar foo baz foo", "foo", "qux", 2],
    expected: {
      result: "qux bar qux baz foo",
      replacements: 2,
    },
  },
  {
    name: "multiline content replacement",
    input: [
`function oldName() {
  console.log('oldName');
  return oldName;
}`,
      "oldName",
      "newName",
    ],
    expected: {
      result: 
`function newName() {
  console.log('newName');
  return newName;
}`,
      replacements: 3,
    },
  },
  {
    name: "multiline search and replace",
    input: [
`const config = {
  old: {
    setting: true
  },
  other: false
};`,
`old: {
    setting: true
  }`,
`new: {
    setting: false,
    extra: 'value'
  }`,
    ],
    expected: {
      result: 
`const config = {
  new: {
    setting: false,
    extra: 'value'
  },
  other: false
};`,
      replacements: 1,
    },
  },
  {
    name: "replace code block with limit",
    input: [
`// TODO: fix this
function broken() {
  // TODO: fix this
  return null;
}
// TODO: fix this`,
      "// TODO: fix this",
      "// FIXED",
      2,
    ],
    expected: {
      result: 
`// FIXED
function broken() {
  // FIXED
  return null;
}
// TODO: fix this`,
      replacements: 2,
    },
  },
  {
    name: "no matches in multiline",
    input: [
`Line 1
Line 2
Line 3`,
      "Line 4",
      "Line X",
    ],
    expected: {
      result: 
`Line 1
Line 2
Line 3`,
      replacements: 0,
    },
  },
  {
    name: "empty old text",
    input: ["hello world", "", "xyz"],
    throws: "old_text cannot be empty",
  },
  {
    name: "overlapping replacements",
    input: ["aaaa", "aa", "b"],
    expected: {
      result: "bb",
      replacements: 2,
    },
  },
  {
    name: "replace with empty string",
    input: ["foo bar foo", "foo ", ""],
    expected: {
      result: "bar foo",
      replacements: 1,
    },
  },
  {
    name: "windows line endings",
    input: ["line1\r\nline2\r\nline3", "\r\n", "\n"],
    expected: {
      result: "line1\nline2\nline3",
      replacements: 2,
    },
  },
  {
    name: "indent-sensitive replacement",
    input: [
`class OldClass:
    def method(self):
        pass`,
      "OldClass",
      "NewClass",
    ],
    expected: {
      result: 
`class NewClass:
    def method(self):
        pass`,
      replacements: 1,
    },
  },
];

=== END FILE: ./test-data/unit/replaceText.cases.ts ===

=== START FILE: ./test-data/unit/formatNodeError.cases.json ===
{
  "cases": [
    {
      "name": "ENOENT error",
      "input": [
        { "code": "ENOENT", "message": "no such file or directory" },
        "/tmp/missing.txt",
        "open"
      ],
      "expected": "ENOENT: no such file or directory, open '/tmp/missing.txt'"
    },
    {
      "name": "EEXIST error",
      "input": [
        { "code": "EEXIST", "message": "file already exists" },
        "/tmp/existing.txt",
        "open"
      ],
      "expected": "EEXIST: file already exists, open '/tmp/existing.txt'"
    },
    {
      "name": "EACCES error",
      "input": [
        { "code": "EACCES", "message": "permission denied" },
        "/root/forbidden.txt",
        "open"
      ],
      "expected": "EACCES: permission denied, open '/root/forbidden.txt'"
    },
    {
      "name": "EISDIR error",
      "input": [
        { "code": "EISDIR", "message": "illegal operation on a directory" },
        "/tmp/",
        "read"
      ],
      "expected": "EISDIR: illegal operation on a directory, read '/tmp/'"
    },
    {
      "name": "unknown error code",
      "input": [
        { "code": "ESOMETHING", "message": "something went wrong" },
        "/tmp/file.txt",
        "write"
      ],
      "expected": "ESOMETHING: something went wrong"
    },
    {
      "name": "error without code",
      "input": [
        { "message": "Generic error occurred" },
        "/tmp/file.txt",
        "write"
      ],
      "expected": "Generic error occurred"
    },
    {
      "name": "error with no message or code",
      "input": [
        {},
        "/tmp/file.txt",
        "write"
      ],
      "expected": "Unknown error during write on '/tmp/file.txt'"
    },
    {
      "name": "rename ENOENT error",
      "input": [
        { "code": "ENOENT", "message": "no such file or directory" },
        "/tmp/source.txt",
        "rename",
        "/tmp/dest.txt"
      ],
      "expected": "ENOENT: no such file or directory, rename '/tmp/source.txt' -> '/tmp/dest.txt'"
    },
    {
      "name": "rename EACCES error",
      "input": [
        { "code": "EACCES", "message": "permission denied" },
        "/tmp/source.txt",
        "rename",
        "/root/dest.txt"
      ],
      "expected": "EACCES: permission denied, rename '/tmp/source.txt' -> '/root/dest.txt'"
    }
  ]
}
=== END FILE: ./test-data/unit/formatNodeError.cases.json ===

=== START FILE: ./test-data/integration/file-operations.cases.md ===
# File Operations Integration Tests

**Status**: [PLANNED] - Preliminary test format, subject to change

## file_write

### 001-simple-file-create

```sh sham
#!SHAM [@three-char-SHA-256: abc]
action = "file_write"
path = "/tmp/test.txt"
content = "Hello, World!"
#!END_SHAM_abc
```

```json
{
  "success": true,
  "data": {
    "path": "/tmp/test.txt",
    "bytesWritten": 13
  }
}
```

### 002-create-with-parent-dirs

```sh sham
#!SHAM [@three-char-SHA-256: pdr]
action = "file_write"
path = "/tmp/deeply/nested/dir/file.txt"
content = "Creates parent directories"
#!END_SHAM_pdr
```

```json
{
  "success": true,
  "data": {
    "path": "/tmp/deeply/nested/dir/file.txt",
    "bytesWritten": 26
  }
}
```


### 003-write-with-special-characters

```sh sham
#!SHAM [@three-char-SHA-256: spc]
action = "file_write"
path = "/tmp/special-chars.txt"
content = "Line with \"quotes\" and 'apostrophes'"
#!END_SHAM_spc
```

```json
{
  "success": true,
  "data": {
    "path": "/tmp/special-chars.txt",
    "bytesWritten": 36
  }
}
```

### 004-multiline-content

```sh sham
#!SHAM [@three-char-SHA-256: mlt]
action = "file_write"
path = "/tmp/multiline.txt"
content = <<'EOT_SHAM_mlt'
Line 1
Line 2
Line 3
EOT_SHAM_mlt
#!END_SHAM_mlt
```

```json
{
  "success": true,
  "data": {
    "path": "/tmp/multiline.txt",
    "bytesWritten": 20
  }
}
```

## file_delete

### 001-delete-existing-file

```sh sham
#!SHAM [@three-char-SHA-256: del]
action = "file_delete"
path = "/tmp/to-delete.txt"
#!END_SHAM_del
```

```json
{
  "success": true,
  "data": {
    "path": "/tmp/to-delete.txt"
  }
}
```

### 002-delete-nonexistent-file

```sh sham
#!SHAM [@three-char-SHA-256: dnf]
action = "file_delete"
path = "/tmp/does-not-exist.txt"
#!END_SHAM_dnf
```

```json
{
  "success": false,
  "error": "ENOENT: no such file or directory, unlink '/tmp/does-not-exist.txt'"
}
```

## file_replace_text

### 001-simple-text-replacement

```sh sham
#!SHAM [@three-char-SHA-256: rpl]
action = "file_replace_text"
path = "/tmp/replace-test.txt"
old_text = "Hello"
new_text = "Goodbye"
#!END_SHAM_rpl
```

```json
{
  "success": true,
  "data": {
    "path": "/tmp/replace-test.txt",
    "replacements": 1
  }
}
```

### 002-replace-with-count-limit

```sh sham
#!SHAM [@three-char-SHA-256: cnt]
action = "file_replace_text"
path = "/tmp/multi-replace.txt"
old_text = "foo"
new_text = "bar"
count = 2
#!END_SHAM_cnt
```

```json
{
  "success": true,
  "data": {
    "path": "/tmp/multi-replace.txt",
    "replacements": 2
  }
}
```

### 003-replace-text-not-found

```sh sham
#!SHAM [@three-char-SHA-256: nfr]
action = "file_replace_text"
path = "/tmp/no-match.txt"
old_text = "nonexistent"
new_text = "replacement"
#!END_SHAM_nfr
```

```json
{
  "success": true,
  "data": {
    "path": "/tmp/no-match.txt",
    "replacements": 0
  }
}
```

### 004-replace-in-nonexistent-file

```sh sham
#!SHAM [@three-char-SHA-256: rnf]
action = "file_replace_text"
path = "/tmp/does-not-exist-replace.txt"
old_text = "text"
new_text = "other"
#!END_SHAM_rnf
```

```json
{
  "success": false,
  "error": "ENOENT: no such file or directory, open '/tmp/does-not-exist-replace.txt'"
}
```

### 005-multiline-replacement

```sh sham
#!SHAM [@three-char-SHA-256: mlr]
action = "file_replace_text"
path = "/tmp/multiline-replace.txt"
old_text = <<'EOT_SHAM_mlr'
function oldName() {
  return oldName;
}
EOT_SHAM_mlr
new_text = <<'EOT_SHAM_mlr'
function newName() {
  return newName;
}
EOT_SHAM_mlr
#!END_SHAM_mlr
```

```json
{
  "success": true,
  "data": {
    "path": "/tmp/multiline-replace.txt",
    "replacements": 1
  }
}
```

### 006-empty-old-text-error

```sh sham
#!SHAM [@three-char-SHA-256: emt]
action = "file_replace_text"
path = "/tmp/empty-search.txt"
old_text = ""
new_text = "something"
#!END_SHAM_emt
```

```json
{
  "success": false,
  "error": "file_replace_text: old_text cannot be empty"
}
```

## file_read

### 001-read-existing-file

```sh sham
#!SHAM [@three-char-SHA-256: rdf]
action = "file_read"
path = "/tmp/readable.txt"
#!END_SHAM_rdf
```

```json
{
  "success": true,
  "data": {
    "path": "/tmp/readable.txt",
    "content": "This is readable content"
  }
}
```

### 002-read-nonexistent-file

```sh sham
#!SHAM [@three-char-SHA-256: rnx]
action = "file_read"
path = "/tmp/not-there.txt"
#!END_SHAM_rnx
```

```json
{
  "success": false,
  "error": "ENOENT: no such file or directory, open '/tmp/not-there.txt'"
}
```

## file_move

### 001-move-file-simple

```sh sham
#!SHAM [@three-char-SHA-256: mvs]
action = "file_move"
old_path = "/tmp/source.txt"
new_path = "/tmp/destination.txt"
#!END_SHAM_mvs
```

```json
{
  "success": true,
  "data": {
    "old_path": "/tmp/source.txt",
    "new_path": "/tmp/destination.txt"
  }
}
```

### 002-move-file-to-new-directory

```sh sham
#!SHAM [@three-char-SHA-256: mvd]
action = "file_move"
old_path = "/tmp/original.txt"
new_path = "/tmp/new-dir/moved.txt"
#!END_SHAM_mvd
```

```json
{
  "success": true,
  "data": {
    "old_path": "/tmp/original.txt",
    "new_path": "/tmp/new-dir/moved.txt"
  }
}
```

### 003-move-nonexistent-file

```sh sham
#!SHAM [@three-char-SHA-256: mnf]
action = "file_move"
old_path = "/tmp/ghost.txt"
new_path = "/tmp/nowhere.txt"
#!END_SHAM_mnf
```

```json
{
  "success": false,
  "error": "file_move: Source file not found '/tmp/ghost.txt' (ENOENT)"
}
```

### 004-move-to-existing-file

```sh sham
#!SHAM [@three-char-SHA-256: mef]
action = "file_move"
old_path = "/tmp/source-exists.txt"
new_path = "/tmp/dest-exists.txt"
#!END_SHAM_mef
```

```json
{
  "success": true,
  "data": {
    "old_path": "/tmp/source-exists.txt",
    "new_path": "/tmp/dest-exists.txt",
    "overwrote": true
  }
}
```
=== END FILE: ./test-data/integration/file-operations.cases.md ===

=== START FILE: ./doc/API.md ===
# Component: fs-ops

## Component Type
standard

## Documentation Debt
- [ ] Integration test format is preliminary [IMPLEMENTED]
- [ ] Error handling strategy needs refinement
- [ ] Consider batching operations for efficiency

## Dependencies

```yaml
dependencies:
  node:fs/promises:
    functions: [writeFile, unlink, mkdir, rename, stat]
    # Note: removed unused - readFile, rmdir, readdir (not yet implemented)
    
  node:path:
    functions: [dirname]
    # Note: removed unused - resolve, join (not yet needed)
    
  # Removed node:util - not used
  # Removed node:child_process - grep not yet implemented
```

## Exports

```yaml
exports:
  functions: [executeFileOperation]
  types: [FileOpResult, FileOpError]
```

### executeFileOperation
- **Signature**: `executeFileOperation(action: CladaAction) -> Promise<FileOpResult>`
- **Purpose**: Execute file system operations from parsed SHAM actions
- **Throws**: Never - all errors captured in FileOpResult
- **Test-data**: `test-data/integration/file-operations.md` [PLANNED]

### FileOpResult (type)
```typescript
interface FileOpResult {
  success: boolean
  data?: any           // Operation-specific return data
  error?: string       // Error message if failed
}
```

### FileOpError (type)
```typescript
interface FileOpError extends Error {
  code: string         // e.g., 'ENOENT', 'EACCES'
  path?: string        // File path involved
  operation: string    // Which operation failed
}
```

## Internal Functions

### createFile
- **Signature**: `createFile(path: string, content: string) -> Promise<void>`
- **Purpose**: Create new file with content, creating parent directories as needed

### writeFile  
- **Signature**: `writeFile(path: string, content: string) -> Promise<void>`
- **Purpose**: Overwrite existing file content

### editFile
- **Signature**: `editFile(path: string, oldText: string, newText: string, count?: number) -> Promise<number>`
- **Purpose**: Replace text occurrences in file, returns replacement count

### deleteFile
- **Signature**: `deleteFile(path: string) -> Promise<void>`
- **Purpose**: Remove file

### moveFile
- **Signature**: `moveFile(oldPath: string, newPath: string) -> Promise<void>`
- **Purpose**: Move or rename file

### readFileContent
- **Signature**: `readFileContent(path: string) -> Promise<string>`
- **Purpose**: Read file content as UTF-8 string

### createDirectory
- **Signature**: `createDirectory(path: string) -> Promise<void>`
- **Purpose**: Create directory, including parent directories

### deleteDirectory
- **Signature**: `deleteDirectory(path: string) -> Promise<void>`
- **Purpose**: Remove directory (must be empty)

### listDirectory
- **Signature**: `listDirectory(path: string) -> Promise<DirEntry[]>`
- **Purpose**: List directory contents with metadata

### searchFiles
- **Signature**: `searchFiles(pattern: string, path: string, include?: string) -> Promise<GrepResult[]>`
- **Purpose**: Search for pattern in files (grep-like)

### globFiles
- **Signature**: `globFiles(pattern: string, basePath: string) -> Promise<string[]>`
- **Purpose**: Find files matching glob pattern

## Action Mapping

```typescript
const actionHandlers = {
  'file_write': writeFile,
  'file_replace_text': editFile,
  'file_delete': deleteFile,
  'file_move': moveFile,
  'file_read': readFileContent,
  'dir_create': createDirectory,
  'dir_delete': deleteDirectory,
  'ls': listDirectory,
  'grep': searchFiles,
  'glob': globFiles
}
```
=== END FILE: ./doc/API.md ===

=== START FILE: ./doc/DESIGN_TEMP.md ===
# fs-ops Design & Implementation Notes

**Status**: TEMPORARY - Implementation planning document

## Pseudocode for executeFileOperation

```javascript
async function executeFileOperation(action: CladaAction): Promise<FileOpResult> {
  try {
    // Get handler for action type
    const handler = actionHandlers[action.action];
    
    if (!handler) {
      return {
        success: false,
        error: `Unknown action: ${action.action}`
      };
    }
    
    // Call handler with action
    return await handler(action);
    
  } catch (error) {
    // This should never happen - handlers should catch their own errors
    return {
      success: false,
      error: `Unexpected error in executeFileOperation: ${error.message}`
    };
  }
}

// Individual handlers extract params and call internal functions
async function handleFileWrite(action: CladaAction): Promise<FileOpResult> {
  const { path, content } = action.parameters;
  
  try {
    
    // Create parent directories if needed
    const parentDir = dirname(path);
    const createdDirs = await ensureDirectoryExists(parentDir);
    
    // Write file
    const bytesWritten = await writeFileInternal(path, content);
    
    const result: FileOpResult = {
      success: true,
      data: {
        path,
        bytesWritten
      }
    };
    
    if (createdDirs.length > 0) {
      result.data.createdDirs = createdDirs;
    }
    
    return result;
    
  } catch (error) {
    return {
      success: false,
      error: formatNodeError(error, path, 'file_write')
    };
  }
}
```

## Extracted Pure Functions Needed

### Core File Operations
- `writeFileInternal(path: string, content: string): Promise<number>` - Returns bytes written
- `fileExists(path: string): Promise<boolean>` - Check if file exists
- `ensureDirectoryExists(path: string): Promise<string[]>` - Creates dirs, returns created paths
- `formatNodeError(error: any, path: string, operation: string): string` - Format Node errors consistently ✅

### Path Utilities (Pure)
- `getParentDirectory(path: string): string` - Extract parent dir from path ✅
- `normalizePath(path: string): string` - Normalize path separators
- `getCreatedDirectories(targetPath: string, existingPaths: Set<string>): string[]` - Determine which dirs were created

### Content Utilities (Pure)
- `getByteLength(content: string): number` - Calculate UTF-8 byte length ✅
- `replaceText(content: string, oldText: string, newText: string, count?: number): {result: string, replacements: number}` - Replace text occurrences ✅

### Directory Listing (Pure)
- `formatDirEntry(name: string, stats: Stats): DirEntry` - Format stat info into our type

## Implementation Progress

### Completed Pure Functions
1. ✅ `getParentDirectory` - Path extraction
2. ✅ `getByteLength` - UTF-8 byte counting
3. ✅ `replaceText` - Text replacement with count
4. ✅ `formatNodeError` - Error message formatting

## Implementation Order

1. **Path utilities** (pure functions, easy to test)
2. **Content utilities** (pure functions)
3. **Core file operations** (async, need mocking for tests)
4. **Action handlers** (integrate everything)

## Error Handling Strategy

- All internal functions throw native errors
- Handlers catch and format errors into FileOpResult
- Preserve original error codes (ENOENT, EACCES, etc.)
- Add context about what operation was attempted

## Test Data Structure Ideas

For pure functions:
```json
{
  "cases": [
    {
      "name": "extract parent from simple path",
      "input": ["/tmp/test.txt"],
      "expected": "/tmp"
    }
  ]
}
```

For async functions (need to mock fs):
```json
{
  "cases": [
    {
      "name": "file exists returns true",
      "input": ["/tmp/exists.txt"],
      "mockFs": {
        "/tmp/exists.txt": "content"
      },
      "expected": true
    }
  ]
}
```

## Notes

- Integration tests show we need to handle:
  - Creating parent directories automatically
  - Proper error messages matching Node.js format
  - Byte counting for content
  - Permission errors
=== END FILE: ./doc/DESIGN_TEMP.md ===

=== START FILE: ./doc/TODO.md ===
Ambiguous file_replace_text behavior:

- What happens if old_text appears multiple times but count=1? Which occurrence gets replaced?
    
    this results in an error!

What if old_text doesn't exist? Silent success or error?


    error!
=== END FILE: ./doc/TODO.md ===

=== START FILE: ./doc/ABSTRACT.md ===
# File System Operations

Executes file and directory operations from parsed SHAM actions, providing consistent error handling and operation results for LLM feedback.

## Overview

The fs-ops component is the primary executor for file system operations in clada. It receives parsed CladaAction objects from the sham-action-parser and performs the requested file system operations, returning standardized results that include success status, operation-specific data, and detailed error information when operations fail.

The component handles all file-related SHAM actions including file creation, editing, deletion, and reading, as well as directory operations and search functionality. It automatically handles common scenarios like creating parent directories for new files and provides detailed error messages that help the LLM understand why operations failed.

Each operation is designed to be atomic and independent, with no shared state between operations. This ensures predictable behavior and makes it easy for the LLM to reason about the effects of each action.
=== END FILE: ./doc/ABSTRACT.md ===

=== START FILE: ./doc/ARCH.md ===
# fs-ops Architecture

## Design Philosophy

**Defensive Operations with Clear Errors**: Every operation should handle common failure cases gracefully and return descriptive errors that help the LLM understand what went wrong.

## Key Design Decisions

### Parent Directory Creation
- `file_write` automatically creates parent directories.  creates parent directory if it doesn't exist

### Text Replacement Strategy  
- Use exact string matching for `file_replace_text`
- Count parameter limits replacements (default: 1)
- Return actual number of replacements made
- No regex support (keep it simple, predictable)

### Error Handling
- Never throw - return errors in result object
- Include original error codes (ENOENT, EACCES)
- Add context about what operation was attempted
- Preserve stack traces for debugging

### Path Resolution
- All paths must be absolute (validated by parser)
- No path traversal validation (security is out of scope for v1)
- Symlinks followed transparently

### Directory Operations
- `dir_delete` only removes empty directories
- No recursive deletion option (safety)
- `ls` returns flat listing with type info

### Search Operations
- `grep` uses simple substring matching
- Include patterns use glob syntax
- Results include line numbers
- Large file handling: streaming for files >10MB

## Performance Considerations

- File operations are synchronous from caller perspective
- No caching of file contents
- No watch/monitor capabilities
- Each operation is independent

## Encoding

- All text files assumed UTF-8
- Binary files not supported in v1
- Line endings preserved as-is

## Limits

- Max file size: 10MB (from unified-design.yaml)
- No limit on number of operations
- No timeout on individual operations

## Future Considerations

- Batch operations for efficiency
- Binary file support
- File watching/monitoring
- Atomic write operations (write to temp, rename)
- Path validation against allowlist


# fs-ops ARCH.md - Additional Sections

## File Move Behavior

### Overwrite Semantics
- `file_move` overwrites existing destination files without warning
- Matches Unix `mv` behavior and Node.js `rename()` semantics  
- Rationale: LLM can check first if needed, but overwrite-by-default enables single-shot operations
- Return data includes `overwrote: true` when destination existed

### Directory Creation
- `file_move` automatically creates parent directories for destination path
- Diverges from standard `rename()` which fails with ENOENT
- Rationale: Reduces LLM round-trips for common "move to new location" pattern
- Return data includes `createdDirs` array when directories were created

## Error Message Enhancement

### Problem: Ambiguous ENOENT
Node.js returns ENOENT for multiple distinct failures:
- Source file doesn't exist
- Destination directory doesn't exist  
- Parent directory permissions (sometimes)

### Solution: Pre-flight Checks
Operations perform checks before system calls to provide specific errors:
- `file_move`: Check source exists → "Source file not found" vs generic ENOENT
- `file_write`: Already creates parent dirs, avoiding ambiguity
- `file_delete`: Pass through Node errors (unambiguous)

### Error Format
When enhancing errors for LLM clarity:
```
{operation}: {specific_issue} '{path}' ({error_code})
```

Example: `file_move: Source file not found '/tmp/ghost.txt' (ENOENT)`
=== END FILE: ./doc/ARCH.md ===

=== START FILE: ./src/formatNodeError.ts ===
/**
 * Format Node.js filesystem errors into consistent error messages
 * @param error - The error object from Node.js
 * @param path - The file path involved in the operation
 * @param operation - The operation that was attempted
 * @returns Formatted error message string
 */
export function formatNodeError(error: any, path: string, operation: string, dest?: string): string {
  // Node.js errors have a code property
  if (error.code) {
    switch (error.code) {
      case 'ENOENT':
        if (operation === 'rename' && dest) {
          return `ENOENT: no such file or directory, rename '${path}' -> '${dest}'`;
        }
        return `ENOENT: no such file or directory, ${operation} '${path}'`;
      case 'EEXIST':
        return `EEXIST: file already exists, ${operation} '${path}'`;
      case 'EACCES':
        if (operation === 'rename' && dest) {
          return `EACCES: permission denied, rename '${path}' -> '${dest}'`;
        }
        return `EACCES: permission denied, ${operation} '${path}'`;
      case 'EISDIR':
        return `EISDIR: illegal operation on a directory, ${operation} '${path}'`;
      case 'ENOTDIR':
        return `ENOTDIR: not a directory, ${operation} '${path}'`;
      case 'ENOTEMPTY':
        return `ENOTEMPTY: directory not empty, ${operation} '${path}'`;
      default:
        return `${error.code}: ${error.message}`;
    }
  }
  
  // Fallback for non-Node errors
  return error.message || `Unknown error during ${operation} on '${path}'`;
}
=== END FILE: ./src/formatNodeError.ts ===

=== START FILE: ./src/fileSystemUtils.ts ===
import { stat } from 'fs/promises';

/**
 * Check if a file or directory exists
 * @param path - File or directory path to check
 * @returns true if exists, false otherwise
 */
export async function fileExists(path: string): Promise<boolean> {
  try {
    await stat(path);
    return true;
  } catch {
    return false;
  }
}
=== END FILE: ./src/fileSystemUtils.ts ===

=== START FILE: ./src/replaceText.ts ===
/**
 * Replace occurrences of text in content with optional count limit
 * @param content - Original content
 * @param oldText - Text to find and replace
 * @param newText - Replacement text
 * @param count - Maximum replacements (default: replace all)
 * @returns Object with result string and number of replacements made
 */
export function replaceText(
  content: string, 
  oldText: string, 
  newText: string, 
  count?: number
): { result: string; replacements: number } {
  if (oldText === '') {
    throw new Error('old_text cannot be empty');
  }

  let result = content;
  let replacements = 0;
  let startIndex = 0;

  while (true) {
    const index = result.indexOf(oldText, startIndex);
    if (index === -1) break;
    
    if (count !== undefined && replacements >= count) break;
    
    result = result.slice(0, index) + newText + result.slice(index + oldText.length);
    startIndex = index + newText.length;
    replacements++;
  }

  return { result, replacements };
}
=== END FILE: ./src/replaceText.ts ===

=== START FILE: ./src/index.ts ===
/**
 * fs-ops - File system operations executor for clada
 * 
 * Handles all file and directory operations from parsed SHAM actions
 */

import type { CladaAction } from '../../sham-action-parser/src/index.js';
import { writeFile, mkdir, unlink, rename } from 'fs/promises';
import { dirname } from 'path';
import { formatNodeError } from './formatNodeError.js';
import { fileExists } from './fileSystemUtils.js';

export interface FileOpResult {
  success: boolean;
  data?: any;
  error?: string;
}

export class FileOpError extends Error {
  constructor(
    message: string,
    public code: string,
    public path?: string,
    public operation?: string
  ) {
    super(message);
    this.name = 'FileOpError';
  }
}

/**
 * Execute a file system operation from a parsed SHAM action
 * Never throws - all errors returned in result
 */
export async function executeFileOperation(action: CladaAction): Promise<FileOpResult> {
  try {
    const handler = actionHandlers[action.action];
    
    if (!handler) {
      return {
        success: false,
        error: `Unknown action: ${action.action}`
      };
    }
    
    return await handler(action);
    
  } catch (error: any) {
    // This should never happen - handlers should catch their own errors
    return {
      success: false,
      error: `Unexpected error in executeFileOperation: ${error.message}`
    };
  }
}

/**
 * Handle file_move action - moves/renames a file
 * Creates parent directories for destination if needed
 * Overwrites destination if it exists
 */
async function handleFileMove(action: CladaAction): Promise<FileOpResult> {
  const { old_path, new_path } = action.parameters;
  
  try {
    // Pre-flight check for better error messages
    const sourceExists = await fileExists(old_path);
    if (!sourceExists) {
      return {
        success: false,
        error: `file_move: Source file not found '${old_path}' (ENOENT)`
      };
    }
    
    // Check if destination exists (for overwrote flag)
    const destExists = await fileExists(new_path);
    
    // Create parent directories for destination
    const parentDir = dirname(new_path);
    await mkdir(parentDir, { recursive: true });
    
    // Move the file
    await rename(old_path, new_path);
    
    const result: FileOpResult = {
      success: true,
      data: {
        old_path,
        new_path
      }
    };
    
    if (destExists) {
      result.data.overwrote = true;
    }
    
    return result;
    
  } catch (error: any) {
    return {
      success: false,
      error: formatNodeError(error, old_path, 'rename', new_path)
    };
  }
}

/**
 * Handle file_delete action - removes a file
 */
async function handleFileDelete(action: CladaAction): Promise<FileOpResult> {
  const { path } = action.parameters;
  
  try {
    await unlink(path);
    
    return {
      success: true,
      data: {
        path
      }
    };
    
  } catch (error: any) {
    return {
      success: false,
      error: formatNodeError(error, path, 'unlink')
    };
  }
}

/**
 * Handle file_write action - writes/creates/overwrites a file with content
 * Automatically creates parent directories if needed
 */
async function handleFileWrite(action: CladaAction): Promise<FileOpResult> {
  const { path, content } = action.parameters;
  
  try {
    // Create parent directories if needed
    const parentDir = dirname(path);
    await mkdir(parentDir, { recursive: true });
    
    // Write file
    await writeFile(path, content, 'utf8');
    const bytesWritten = Buffer.byteLength(content, 'utf8');
    
    return {
      success: true,
      data: {
        path,
        bytesWritten
      }
    };
    
  } catch (error: any) {
    return {
      success: false,
      error: formatNodeError(error, path, 'open')
    };
  }
}

// Internal function stubs for each operation

async function createFile(path: string, content: string): Promise<void> {
  throw new Error('Not implemented');
}

 

async function replaceTextInFile(path: string, oldText: string, newText: string, count?: number): Promise<number> {
  throw new Error('Not implemented');
}

async function deleteFile(path: string): Promise<void> {
  throw new Error('Not implemented');
}

async function moveFile(oldPath: string, newPath: string): Promise<void> {
  throw new Error('Not implemented');
}

async function readFileContent(path: string): Promise<string> {
  throw new Error('Not implemented');
}

async function createDirectory(path: string): Promise<void> {
  throw new Error('Not implemented');
}

async function deleteDirectory(path: string): Promise<void> {
  throw new Error('Not implemented');
}

interface DirEntry {
  name: string;
  type: 'file' | 'directory';
  size: number;
  modified: Date;
}

async function listDirectory(path: string): Promise<DirEntry[]> {
  throw new Error('Not implemented');
}

interface GrepResult {
  file: string;
  line_number: number;
  line: string;
}

async function searchFiles(pattern: string, path: string, include?: string): Promise<GrepResult[]> {
  throw new Error('Not implemented');
}

async function globFiles(pattern: string, basePath: string): Promise<string[]> {
  throw new Error('Not implemented');
}

// Action handler mapping
const actionHandlers: Record<string, (action: CladaAction) => Promise<FileOpResult>> = {
  'file_write': handleFileWrite,
  'file_replace_text': async (action) => {
    return { success: false, error: 'Not implemented' };
  },
  'file_delete': handleFileDelete,
  'file_move': handleFileMove,
  'file_read': async (action) => {
    return { success: false, error: 'Not implemented' };
  },
  'dir_create': async (action) => {
    return { success: false, error: 'Not implemented' };
  },
  'dir_delete': async (action) => {
    return { success: false, error: 'Not implemented' };
  },
  'ls': async (action) => {
    return { success: false, error: 'Not implemented' };
  },
  'grep': async (action) => {
    return { success: false, error: 'Not implemented' };
  },
  'glob': async (action) => {
    return { success: false, error: 'Not implemented' };
  }
};
=== END FILE: ./src/index.ts ===
