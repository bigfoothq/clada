=== START FILE: /Users/stuart/repos/clada/proj/comp/listener/test/integration/listener-workflow-v2.test.ts ===
import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { readFile, writeFile, mkdir, rm } from 'fs/promises';
import { join, dirname } from 'path';
import { fileURLToPath } from 'url';
import { marked } from 'marked';
import clipboard from 'clipboardy';

import { startListener } from '../../src/listener.js';
import type { ListenerHandle } from '../../src/types.js';

const __dirname = dirname(fileURLToPath(import.meta.url));

interface TestCase {
  name: string;
  initialContent: string;
  newContent: string;
  expectedPrepended: string;
  expectedOutput: string;
  expectedClipboard: string;
}

// Parse test cases from markdown
async function parseTestCases(): Promise<TestCase[]> {
  const testDataPath = join(__dirname, '../../test-data/integration/listener-workflow-v2.cases.md');
  const markdown = await readFile(testDataPath, 'utf-8');
  
  const tokens = marked.lexer(markdown);
  const testCases: TestCase[] = [];
  let currentTest: Partial<TestCase> | null = null;
  let codeBlockCount = 0;
  
  for (const token of tokens) {
    // Test case name (h3)
    if (token.type === 'heading' && token.depth === 3) {
      // Save previous test if complete
      if (currentTest && currentTest.name && 
          currentTest.initialContent && 
          currentTest.newContent && 
          currentTest.expectedPrepended && 
          currentTest.expectedOutput && 
          currentTest.expectedClipboard) {
        testCases.push(currentTest as TestCase);
      }
      
      // Start new test
      currentTest = { name: token.text };
      codeBlockCount = 0;
    }
    
    // Code blocks - just take them in order, ignoring h4 headers
    if (token.type === 'code' && currentTest) {
      const content = token.text;
      codeBlockCount++;
      
      switch (codeBlockCount) {
        case 1:
          currentTest.initialContent = content;
          break;
        case 2:
          currentTest.newContent = content;
          break;
        case 3:
          currentTest.expectedPrepended = content;
          break;
        case 4:
          currentTest.expectedOutput = content;
          break;
        case 5:
          currentTest.expectedClipboard = content;
          break;
      }
    }
  }
  
  // Don't forget the last test case
  if (currentTest && currentTest.name && 
      currentTest.initialContent && 
      currentTest.newContent && 
      currentTest.expectedPrepended && 
      currentTest.expectedOutput && 
      currentTest.expectedClipboard) {
    testCases.push(currentTest as TestCase);
  }
  
  return testCases;
}

// Helper to extract test directory name from test case
function getTestDir(testCaseName: string): string {
  const safeName = testCaseName.toLowerCase().replace(/[^a-z0-9]+/g, '-');
  return `/tmp/t_listener_${safeName}`;
}

// Helper to poll for file content change
async function pollForFileChange(
  filePath: string,
  initialContent: string,
  timeoutMs: number = 5000
): Promise<string> {
  const startTime = Date.now();
  let lastContent = initialContent;
  
  while (Date.now() - startTime < timeoutMs) {
    try {
      const content = await readFile(filePath, 'utf-8');
      if (content !== lastContent && content.includes('=== CLADA RESULTS ===')) {
        return content;
      }
      lastContent = content;
    } catch {}
    await new Promise(resolve => setTimeout(resolve, 100));
  }
  throw new Error(`Timeout waiting for file change after ${timeoutMs}ms`);
}

describe('listener workflow v2', async () => {
  const testCases = await parseTestCases();
  
  for (const testCase of testCases) {
    it(testCase.name, async () => {
      let handle: ListenerHandle | null = null;
      const testDir = getTestDir(testCase.name);
      const testFile = join(testDir, 'test.txt');
      const outputFile = join(testDir, '.clada-output-latest.txt');
      
      try {
        // Setup
        await mkdir(testDir, { recursive: true });
        await writeFile(testFile, testCase.initialContent);
        
        // Start listener
        handle = await startListener({ 
          filePath: testFile, 
          debounceMs: 100 
        });
        
        // Wait for initial processing
        await pollForFileChange(testFile, testCase.initialContent);
        
        // Wait for debounce to settle
        await new Promise(resolve => setTimeout(resolve, 200));
        
        // Write new content
        await writeFile(testFile, testCase.newContent);
        
        // Wait for processing to complete
        await pollForFileChange(testFile, testCase.newContent);
        
        // Wait a bit more for clipboard and output file writes
        await new Promise(resolve => setTimeout(resolve, 200));
        
        // Read actual results
        const actualPrepended = await readFile(testFile, 'utf-8');
        const actualOutput = await readFile(outputFile, 'utf-8');
        const actualClipboard = await clipboard.read();
        
        // Compare results (exact match)
        expect(actualPrepended).toBe(testCase.expectedPrepended);
        expect(actualOutput).toBe(testCase.expectedOutput);
        expect(actualClipboard).toBe(testCase.expectedClipboard);
        
      } finally {
        // Cleanup
        if (handle) {
          await handle.stop();
        }
        await rm(testDir, { recursive: true, force: true });
      }
    });
  }
});
=== END FILE: /Users/stuart/repos/clada/proj/comp/listener/test/integration/listener-workflow-v2.test.ts ===

=== START FILE: /Users/stuart/repos/clada/proj/comp/listener/test-data/integration/listener-workflow-v2.cases.md ===
# Listener Workflow Integration Tests v2

## listener-workflow-v2

### simple-file-write

#### input file

````sh
Just a simple text file.
Nothing special here.
````

#### input file
````sh
Just a simple text file.
Nothing special here.

```sh sham
#!SHAM [@three-char-SHA-256: sf1]
action = "file_write"
path = "/tmp/t_listener_simple/output.txt"
content = "Hello from SHAM!"
#!END_SHAM_sf1
```
````


#### input file
````sh
üìã Copied to clipboard

=== CLADA RESULTS ===
sf1 ‚úÖ file_write /tmp/t_listener_simple/output.txt
=== END ===

Just a simple text file.
Nothing special here.

```sh sham
#!SHAM [@three-char-SHA-256: sf1]
action = "file_write"
path = "/tmp/t_listener_simple/output.txt"
content = "Hello from SHAM!"
#!END_SHAM_sf1
```
````

#### output file
````sh
=== CLADA RESULTS ===
sf1 ‚úÖ file_write /tmp/t_listener_simple/output.txt
=== END ===

=== OUTPUTS ===
=== END ===
````

#### clipboard
````sh
=== CLADA RESULTS ===
sf1 ‚úÖ file_write /tmp/t_listener_simple/output.txt
=== END ===

=== OUTPUTS ===
=== END ===
````

### multiple-actions-mixed-results

#### input file

````sh
Empty file to start.
````

#### input file
````sh
Empty file to start.

```sh sham
#!SHAM [@three-char-SHA-256: wr1]
action = "file_write"
path = "/tmp/t_listener_multi/created.txt"
content = "This will succeed"
#!END_SHAM_wr1
```

```sh sham
#!SHAM [@three-char-SHA-256: rd1]
action = "file_read"
path = "/tmp/t_listener_multi/missing.txt"
#!END_SHAM_rd1
```

```sh sham
#!SHAM [@three-char-SHA-256: ex1]
action = "exec"
lang = "bash"
code = "echo 'Hello from bash'"
#!END_SHAM_ex1
```
````

#### input file
````sh
üìã Copied to clipboard

=== CLADA RESULTS ===
wr1 ‚úÖ file_write /tmp/t_listener_multi/created.txt
rd1 ‚ùå file_read /tmp/t_listener_multi/missing.txt - File not found
ex1 ‚úÖ exec bash
=== END ===

Empty file to start.

```sh sham
#!SHAM [@three-char-SHA-256: wr1]
action = "file_write"
path = "/tmp/t_listener_multi/created.txt"
content = "This will succeed"
#!END_SHAM_wr1
```

```sh sham
#!SHAM [@three-char-SHA-256: rd1]
action = "file_read"
path = "/tmp/t_listener_multi/missing.txt"
#!END_SHAM_rd1
```

```sh sham
#!SHAM [@three-char-SHA-256: ex1]
action = "exec"
lang = "bash"
code = "echo 'Hello from bash'"
#!END_SHAM_ex1
```
````

#### output file
````sh
=== CLADA RESULTS ===
wr1 ‚úÖ file_write /tmp/t_listener_multi/created.txt
rd1 ‚ùå file_read /tmp/t_listener_multi/missing.txt - File not found
ex1 ‚úÖ exec bash
=== END ===

=== OUTPUTS ===

[ex1] exec bash:
stdout:
Hello from bash
=== END ===
````

#### clipboard
````sh
=== CLADA RESULTS ===
wr1 ‚úÖ file_write /tmp/t_listener_multi/created.txt
rd1 ‚ùå file_read /tmp/t_listener_multi/missing.txt - File not found
ex1 ‚úÖ exec bash
=== END ===

=== OUTPUTS ===

[ex1] exec bash:
stdout:
Hello from bash
=== END ===
````

### parse-error-handling

#### Initial Content
````sh
Testing parse errors.
````

#### New Content
````sh
Testing parse errors.

```sh sham
#!SHAM [@three-char-SHA-256: bad]
action = "file_write"
path = "/tmp/t_listener_parse/test.txt"
content = "missing closing quote
#!END_SHAM_bad
```
````

#### Expected Prepended Results
````sh
üìã Copied to clipboard

=== CLADA RESULTS ===
bad ‚ùå file_write - Unclosed quoted string
=== END ===

Testing parse errors.

```sh sham
#!SHAM [@three-char-SHA-256: bad]
action = "file_write"
path = "/tmp/t_listener_parse/test.txt"
content = "missing closing quote
#!END_SHAM_bad
```
````

#### Expected Output File
````sh
=== CLADA RESULTS ===
bad ‚ùå file_write - Unclosed quoted string
=== END ===

=== OUTPUTS ===
=== END ===
````

#### clipboard
````sh
=== CLADA RESULTS ===
bad ‚ùå file_write - Unclosed quoted string
=== END ===

=== OUTPUTS ===
=== END ===
````

### no-reexecution-on-same-content

#### Initial Content
````sh
Testing hash-based execution.
````

#### New Content
````sh
Testing hash-based execution.

```sh sham
#!SHAM [@three-char-SHA-256: nc1]
action = "file_write"
path = "/tmp/t_listener_nochange/counter.txt"
content = "1"
#!END_SHAM_nc1
```

Adding a comment outside SHAM blocks.
````

#### Expected Prepended Results
````sh
üìã Copied to clipboard

=== CLADA RESULTS ===
nc1 ‚úÖ file_write /tmp/t_listener_nochange/counter.txt
=== END ===

Testing hash-based execution.

```sh sham
#!SHAM [@three-char-SHA-256: nc1]
action = "file_write"
path = "/tmp/t_listener_nochange/counter.txt"
content = "1"
#!END_SHAM_nc1
```

Adding a comment outside SHAM blocks.
````

#### Expected Output File
````sh
=== CLADA RESULTS ===
nc1 ‚úÖ file_write /tmp/t_listener_nochange/counter.txt
=== END ===

=== OUTPUTS ===
=== END ===
````

#### clipboard
````sh
=== CLADA RESULTS ===
nc1 ‚úÖ file_write /tmp/t_listener_nochange/counter.txt
=== END ===

=== OUTPUTS ===
=== END ===
````

### successful-file-replace-text

#### Initial Content
````sh
Testing file replacement functionality.
````

#### New Content
````sh
Testing file replacement functionality.

```sh sham
#!SHAM [@three-char-SHA-256: fr1]
action = "file_write"
path = "/tmp/t_listener_replace/config.yaml"
content = <<'EOT_SHAM_fr1'
# Configuration file
database:
  host: localhost
  port: 5432
  name: myapp_dev

server:
  host: localhost
  port: 3000
EOT_SHAM_fr1
#!END_SHAM_fr1
```

```sh sham
#!SHAM [@three-char-SHA-256: fr2]
action = "file_replace_text"
path = "/tmp/t_listener_replace/config.yaml"
old_text = <<'EOT_SHAM_fr2'
database:
  host: localhost
  port: 5432
  name: myapp_dev
EOT_SHAM_fr2
new_text = <<'EOT_SHAM_fr2'
database:
  host: production.example.com
  port: 5432
  name: myapp_prod
EOT_SHAM_fr2
#!END_SHAM_fr2
```
````

#### Expected Prepended Results
````sh
üìã Copied to clipboard

=== CLADA RESULTS ===
fr1 ‚úÖ file_write /tmp/t_listener_replace/config.yaml
fr2 ‚úÖ file_replace_text /tmp/t_listener_replace/config.yaml
=== END ===

Testing file replacement functionality.

```sh sham
#!SHAM [@three-char-SHA-256: fr1]
action = "file_write"
path = "/tmp/t_listener_replace/config.yaml"
content = <<'EOT_SHAM_fr1'
# Configuration file
database:
  host: localhost
  port: 5432
  name: myapp_dev

server:
  host: localhost
  port: 3000
EOT_SHAM_fr1
#!END_SHAM_fr1
```

```sh sham
#!SHAM [@three-char-SHA-256: fr2]
action = "file_replace_text"
path = "/tmp/t_listener_replace/config.yaml"
old_text = <<'EOT_SHAM_fr2'
database:
  host: localhost
  port: 5432
  name: myapp_dev
EOT_SHAM_fr2
new_text = <<'EOT_SHAM_fr2'
database:
  host: production.example.com
  port: 5432
  name: myapp_prod
EOT_SHAM_fr2
#!END_SHAM_fr2
```
````

#### Expected Output File
````sh
=== CLADA RESULTS ===
fr1 ‚úÖ file_write /tmp/t_listener_replace/config.yaml
fr2 ‚úÖ file_replace_text /tmp/t_listener_replace/config.yaml
=== END ===

=== OUTPUTS ===
=== END ===
````

#### clipboard
````sh
=== CLADA RESULTS ===
fr1 ‚úÖ file_write /tmp/t_listener_replace/config.yaml
fr2 ‚úÖ file_replace_text /tmp/t_listener_replace/config.yaml
=== END ===

=== OUTPUTS ===
=== END ===
````

### failed-file-replace-text-multiple-matches

#### Initial Content
````sh
Testing multiple match failure.
````

#### New Content
````sh
Testing multiple match failure.

```sh sham
#!SHAM [@three-char-SHA-256: fm1]
action = "file_write"
path = "/tmp/t_listener_multi_match/app.js"
content = <<'EOT_SHAM_fm1'
// Application code
function process() {
  const value = 100;
  console.log(value);
  
  if (value > 50) {
    console.log("High value");
  }
  
  return value;
}

function validate() {
  const value = 100;
  return value > 0;
}
EOT_SHAM_fm1
#!END_SHAM_fm1
```

```sh sham
#!SHAM [@three-char-SHA-256: fm2]
action = "file_replace_text"
path = "/tmp/t_listener_multi_match/app.js"
old_text = <<'EOT_SHAM_fm2'
  const value = 100;
EOT_SHAM_fm2
new_text = <<'EOT_SHAM_fm2'
  const value = 999;
EOT_SHAM_fm2
#!END_SHAM_fm2
```
````

#### Expected Prepended Results
````sh
üìã Copied to clipboard

=== CLADA RESULTS ===
fm1 ‚úÖ file_write /tmp/t_listener_multi_match/app.js
fm2 ‚ùå file_replace_text /tmp/t_listener_multi_match/app.js - old_text appears 2 times, must appear exactly once
=== END ===

Testing multiple match failure.

```sh sham
#!SHAM [@three-char-SHA-256: fm1]
action = "file_write"
path = "/tmp/t_listener_multi_match/app.js"
content = <<'EOT_SHAM_fm1'
// Application code
function process() {
  const value = 100;
  console.log(value);
  
  if (value > 50) {
    console.log("High value");
  }
  
  return value;
}

function validate() {
  const value = 100;
  return value > 0;
}
EOT_SHAM_fm1
#!END_SHAM_fm1
```

```sh sham
#!SHAM [@three-char-SHA-256: fm2]
action = "file_replace_text"
path = "/tmp/t_listener_multi_match/app.js"
old_text = <<'EOT_SHAM_fm2'
  const value = 100;
EOT_SHAM_fm2
new_text = <<'EOT_SHAM_fm2'
  const value = 999;
EOT_SHAM_fm2
#!END_SHAM_fm2
```
````

#### Expected Output File
````sh
=== CLADA RESULTS ===
fm1 ‚úÖ file_write /tmp/t_listener_multi_match/app.js
fm2 ‚ùå file_replace_text /tmp/t_listener_multi_match/app.js - old_text appears 2 times, must appear exactly once
=== END ===

=== OUTPUTS ===
=== END ===
````

#### clipboard
````sh
=== CLADA RESULTS ===
fm1 ‚úÖ file_write /tmp/t_listener_multi_match/app.js
fm2 ‚ùå file_replace_text /tmp/t_listener_multi_match/app.js - old_text appears 2 times, must appear exactly once
=== END ===

=== OUTPUTS ===
=== END ===
````

### failed-file-replace-text-no-matches

#### Initial Content
````sh
Testing no match failure.
````

#### New Content
````sh
Testing no match failure.

```sh sham
#!SHAM [@three-char-SHA-256: fn1]
action = "file_write"
path = "/tmp/t_listener_no_match/readme.md"
content = <<'EOT_SHAM_fn1'
# Project README

This is a sample project.

## Installation

Run the following command:
- npm install

## Usage

Start the application with:
- npm start
EOT_SHAM_fn1
#!END_SHAM_fn1
```

```sh sham
#!SHAM [@three-char-SHA-256: fn2]
action = "file_replace_text"
path = "/tmp/t_listener_no_match/readme.md"
old_text = <<'EOT_SHAM_fn2'
## Configuration

Configure the app by editing config.json
EOT_SHAM_fn2
new_text = <<'EOT_SHAM_fn2'
## Configuration

Configure the app by editing settings.yaml
EOT_SHAM_fn2
#!END_SHAM_fn2
```
````

#### Expected Prepended Results
````sh
üìã Copied to clipboard

=== CLADA RESULTS ===
fn1 ‚úÖ file_write /tmp/t_listener_no_match/readme.md
fn2 ‚ùå file_replace_text /tmp/t_listener_no_match/readme.md - old_text not found in file
=== END ===

Testing no match failure.

```sh sham
#!SHAM [@three-char-SHA-256: fn1]
action = "file_write"
path = "/tmp/t_listener_no_match/readme.md"
content = <<'EOT_SHAM_fn1'
# Project README

This is a sample project.

## Installation

Run the following command:
- npm install

## Usage

Start the application with:
- npm start
EOT_SHAM_fn1
#!END_SHAM_fn1
```

```sh sham
#!SHAM [@three-char-SHA-256: fn2]
action = "file_replace_text"
path = "/tmp/t_listener_no_match/readme.md"
old_text = <<'EOT_SHAM_fn2'
## Configuration

Configure the app by editing config.json
EOT_SHAM_fn2
new_text = <<'EOT_SHAM_fn2'
## Configuration

Configure the app by editing settings.yaml
EOT_SHAM_fn2
#!END_SHAM_fn2
```
````

#### Expected Output File
````sh
=== CLADA RESULTS ===
fn1 ‚úÖ file_write /tmp/t_listener_no_match/readme.md
fn2 ‚ùå file_replace_text /tmp/t_listener_no_match/readme.md - old_text not found in file
=== END ===

=== OUTPUTS ===
=== END ===
````

#### clipboard
````sh
=== CLADA RESULTS ===
fn1 ‚úÖ file_write /tmp/t_listener_no_match/readme.md
fn2 ‚ùå file_replace_text /tmp/t_listener_no_match/readme.md - old_text not found in file
=== END ===

=== OUTPUTS ===
=== END ===
````
=== END FILE: /Users/stuart/repos/clada/proj/comp/listener/test-data/integration/listener-workflow-v2.cases.md ===

=== START FILE: /Users/stuart/repos/clada/proj/comp/listener/src/listener.ts ===
import { watchFile, unwatchFile, Stats } from 'fs';
import { readFile, writeFile, access, constants } from 'fs/promises';
import { dirname, join } from 'path';
import clipboard from 'clipboardy';

import type { ListenerConfig, ListenerHandle, ListenerState } from './types.js';
import { ListenerError } from './errors.js';
import { Clada } from '../../orch/src/index.js';
import { formatSummary, formatFullOutput } from './formatters.js';
import { computeContentHash } from './utils.js';

// Module-level state for tracking active listeners
const activeListeners = new Map<string, ListenerHandle>();

// Strip prepended summary section if present
function stripSummarySection(content: string): string {
  const marker = '=== END ===';
  const i = content.lastIndexOf(marker);
  return i === -1 ? content : content.slice(i + marker.length).trimStart();
}


// Debounce utility
function debounce<T extends (...args: any[]) => any>(
  func: T,
  wait: number
): T & { cancel: () => void } {
  let timeout: NodeJS.Timeout | null = null;
  
  const debounced = (...args: Parameters<T>) => {
    if (timeout) clearTimeout(timeout);
    timeout = setTimeout(() => {
      func(...args);
    }, wait);
  };
  
  debounced.cancel = () => {
    if (timeout) clearTimeout(timeout);
  };
  
  return debounced as T & { cancel: () => void };
}

// Generate unique ID for listener instance
function generateId(): string {
  return `listener-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
}

// Format clipboard status line
function formatClipboardStatus(success: boolean, timestamp: Date): string {
  const time = timestamp.toLocaleTimeString();
  return success ?
    `üìã Copied to clipboard` :
    `‚ùå Clipboard copy failed`;
}

// Process file changes
async function processFileChange(filePath: string, state: ListenerState): Promise<void> {
  // Check not already processing
  if (state.isProcessing) return;
  
  try {
    state.isProcessing = true;
    
    // Read file
    const fullContent = await readFile(filePath, 'utf-8');
    if (fullContent.trim() == ""){
      return;
    }
    
    // Strip summary section for hashing
    const contentForHash = stripSummarySection(fullContent).trim();
    
    // // DIAGNOSTIC: Log stripping results
    // console.log('\n=== STRIP SUMMARY ===');
    // console.log('Original length:', fullContent.length);
    // console.log('Stripped length:', contentForHash.length);
    // console.log('Stripped content preview:', contentForHash.substring(0, 150).replace(/\n/g, '\\n'));
    // console.log('=== END STRIP ===\n');
    
    // Compute hash of content (excluding summary)
    const currentHash = computeContentHash(contentForHash);
    
    // // DIAGNOSTIC: Log hash comparison
    // console.log('Current hash:', currentHash);
    // console.log('Last hash:', state.lastExecutedHash);
    
    // Skip if unchanged
    if (currentHash === state.lastExecutedHash) {
      // console.log('Content unchanged, skipping execution');
      return;
    }
    
    // Execute via orchestrator with full file content
    const clada = new Clada({ gitCommit: false });
    const orchResult = await clada.execute(fullContent);
    // console.log('Executed', orchResult.executedActions, 'actions');
    
    // Format outputs
    const timestamp = new Date();
    const summary = formatSummary(orchResult, timestamp);
    const fullOutput = await formatFullOutput(orchResult);
    
    // Copy to clipboard
    let clipboardSuccess = false;
    try {
      await clipboard.write(fullOutput);
      clipboardSuccess = true;
    } catch (error) {
      console.error('listener: Clipboard write failed:', error);
    }
    
    // Format clipboard status
    const clipboardStatus = formatClipboardStatus(clipboardSuccess, timestamp);
    
    // Write output file (without clipboard status)
    await writeFile(state.outputPath, fullOutput);
    
    // Prepend to input file with clipboard status
    const prepend = clipboardStatus + '\n' + summary;
    const updatedContent = prepend + '\n' + fullContent;
    await writeFile(filePath, updatedContent);
    
    // Update state
    state.lastExecutedHash = currentHash;
    
  } catch (error) {
    console.error('listener: Error processing file change:', error);
  } finally {
    state.isProcessing = false;
  }
}

export async function startListener(config: ListenerConfig): Promise<ListenerHandle> {
  // Validate config
  if (!config.filePath) {
    throw new Error('listener: filePath is required');
  }
  if (!config.filePath.startsWith('/')) {
    throw new Error('listener: filePath must be absolute');
  }
  if (config.debounceMs !== undefined && config.debounceMs < 100) {
    throw new Error('listener: debounceMs must be at least 100');
  }
  
  // Check file exists
  try {
    await access(config.filePath, constants.F_OK);
  } catch (error) {
    throw new ListenerError('FILE_NOT_FOUND', config.filePath);
  }
  
  // Check not already watching
  if (activeListeners.has(config.filePath)) {
    throw new ListenerError('ALREADY_WATCHING', config.filePath);
  }
  
  // Initialize state
  const state: ListenerState = {
    lastExecutedHash: '',
    isProcessing: false,
    outputPath: join(dirname(config.filePath), config.outputFilename || '.clada-output-latest.txt')
  };
  
  // Set up debounced handler
  const debouncedProcess = debounce(
    () => {
      // console.log('Debounced process executing');
      processFileChange(config.filePath, state);
    },
    config.debounceMs || 500
  );
  
  // Start watching
  watchFile(config.filePath, { interval: 500 }, (curr: Stats, prev: Stats) => {
    if (curr.mtime !== prev.mtime) {
      // console.log('File change detected, triggering debounced process');
      debouncedProcess();
    }
  });
  
  // Process initial content
  debouncedProcess();
  
  // Create handle
  const handle: ListenerHandle = {
    id: generateId(),
    filePath: config.filePath,
    stop: async () => {
      unwatchFile(config.filePath);
      debouncedProcess.cancel();
      activeListeners.delete(config.filePath);
    }
  };
  
  // Track active listener
  activeListeners.set(config.filePath, handle);
  
  return handle;
}

export async function stopListener(handle: ListenerHandle): Promise<void> {
  await handle.stop();
}
=== END FILE: /Users/stuart/repos/clada/proj/comp/listener/src/listener.ts ===

=== START FILE: /Users/stuart/repos/clada/proj/comp/sham-action-parser/src/index.ts ===
/**
 * SHAM Action Parser - Parses SHAM blocks into validated clada actions
 */

import { ParseResult, CladaAction, ParseError, ValidationResult, TransformError, ActionDefinition } from './types.js';
import { validateShamBlock } from './validateShamBlock.js';
import { transformToAction } from './transformToAction.js';
import { parseSham, type Block, type ParseResult as NeslParseResult } from 'nesl-js';
import { load as loadYaml } from 'js-yaml';
import { readFile } from 'fs/promises';
import { fileURLToPath } from 'url';
import { dirname, join } from 'path';

// Re-export types for consumers
export type { ParseResult, CladaAction, ParseError, ValidationResult, TransformError };

// Cache for action schema
let actionSchemaCache: Map<string, ActionDefinition> | null = null;

/**
 * Clear the action schema cache - useful for testing
 * Forces reload of unified-design.yaml on next parse
 */
export function clearActionSchemaCache(): void {
  actionSchemaCache = null;
}

/**
 * Parse SHAM blocks from text into validated clada actions
 * Processes all blocks, collecting successes and errors
 */
export async function parseShamResponse(shamText: string): Promise<ParseResult> {
  const actions: CladaAction[] = [];
  const errors: ParseError[] = [];

  // Debug logging for specific test cases
  // const isDebugging = shamText.includes('move-to-existing-file');
  // if (isDebugging) {
  //   console.log('DEBUG parseShamResponse: Input text length:', shamText.length);
  //   console.log('DEBUG parseShamResponse: Contains SHAM blocks:', shamText.includes('#!SHAM'));
  //   console.log('DEBUG parseShamResponse: Number of #!SHAM occurrences:', (shamText.match(/#!SHAM/g) || []).length);
  //   console.log('DEBUG parseShamResponse: Number of #!END_SHAM occurrences:', (shamText.match(/#!END_SHAM/g) || []).length);
  // }

  // Parse SHAM blocks using nesl-js
  let parseResult: NeslParseResult;
  try {
   
    parseResult = parseSham(shamText);
    
    // if (isDebugging) {
    //   console.log('DEBUG parseShamResponse: parseSham returned:', parseResult);
    //   if (parseResult) {
    //     console.log('DEBUG parseShamResponse: blocks:', parseResult.blocks?.length || 0);
    //     console.log('DEBUG parseShamResponse: errors:', parseResult.errors?.length || 0);
    //   }
    // }
    
    // Handle case where parseSham returns undefined or null
    if (!parseResult) {
      parseResult = { blocks: [], errors: [] };
    }
  } catch (error) {
    return {
      actions: [],
      errors: [{
        blockId: 'unknown',
        errorType: 'syntax',
        message: `Failed to parse SHAM: ${error}`,
        shamContent: shamText
      }],
      summary: {
        totalBlocks: 0,
        successCount: 0,
        errorCount: 1
      }
    };
  }

  // Process syntax errors from nesl-js parser
  if (parseResult.errors && parseResult.errors.length > 0) {
    for (const parseError of parseResult.errors) {
      // Find the block this error belongs to
      const block = parseResult.blocks?.find(b => b.id === parseError.blockId);
      
      errors.push({
        blockId: parseError.blockId || 'unknown',
        action: block?.properties?.action,
        errorType: 'syntax',
        message: parseError.message,
        blockStartLine: block?.startLine || parseError.line,
        shamContent: parseError.context 
          ? `#!SHAM [@three-char-SHA-256: ${parseError.blockId}]\n${parseError.context}`.trimEnd()
          : reconstructShamBlock(block || { id: parseError.blockId, properties: {} })
      });
    }
  }

  // Load action schema
  const actionSchema = await loadActionSchema();

  // Process each SHAM block
  const blocks = parseResult.blocks || [];
  
  // If no blocks found, return empty result
  if (blocks.length === 0) {
    return {
      actions: [],
      errors: [],
      summary: {
        totalBlocks: 0,
        successCount: 0,
        errorCount: 0
      }
    };
  }
  
  // Track blocks with syntax errors to skip them
  const blocksWithSyntaxErrors = new Set(
    parseResult.errors?.map(e => e.blockId) || []
  );
  
  for (const block of blocks) {
    const blockId = block.id || 'unknown';
    
    // Skip blocks that already have syntax errors
    if (blocksWithSyntaxErrors.has(blockId)) {
      continue;
    }
    
    try {
      // Get action type from block
      const actionType = block.properties?.action;
      const actionDef = actionType ? actionSchema.get(actionType) : undefined;

 

      // Validate block
      const validation = validateShamBlock(block, actionDef ?? null);
      
      if (!validation.valid) {
        errors.push({
          blockId,
          action: actionType,
          errorType: 'validation',
          message: validation.errors?.[0] || 'Validation failed',
          blockStartLine: block.startLine,
          shamContent: reconstructShamBlock(block)
        });
        continue;
      }

      // Transform to action
      try {
        const action = transformToAction(block, actionDef!);
        actions.push(action);
      } catch (error) {
        if (error instanceof TransformError) {
          errors.push({
            blockId,
            action: actionType,
            errorType: 'type',
            message: error.message,
            blockStartLine: block.startLine,
            shamContent: reconstructShamBlock(block)
          });
        } else {
          throw error;
        }
      }
    } catch (error) {
      errors.push({
        blockId,
        action: block.properties?.action,
        errorType: 'validation',
        message: `Unexpected error: ${error}`,
        blockStartLine: block.startLine,
        shamContent: reconstructShamBlock(block)
      });
    }
  }

  const result = {
    actions,
    errors,
    summary: {
      totalBlocks: blocks.length,
      successCount: actions.length,
      errorCount: errors.length
    }
  };
  return result;
}

/**
 * Load and cache action definitions from unified-design.yaml
 */
async function loadActionSchema(): Promise<Map<string, ActionDefinition>> {
 
  if (actionSchemaCache) {
    return actionSchemaCache;
  }

  // Get the directory of this module
  const __filename = fileURLToPath(import.meta.url);
  const __dirname = dirname(__filename);
  
  // Navigate to project root and find unified-design.yaml
  const yamlPath = join(__dirname, '../../../../unified-design.yaml');
  
  try {
    // Add timeout to file read operation
    const yamlContent = await Promise.race([
      readFile(yamlPath, 'utf8'),
      new Promise<never>((_, reject) => 
        setTimeout(() => reject(new Error('YAML read timeout')), 5000)
      )
    ]);
    const design = loadYaml(yamlContent) as any;
    
    actionSchemaCache = new Map();
    
    // Extract tool definitions
    if (design.tools) {
      for (const [toolName, toolDef] of Object.entries(design.tools)) {
        actionSchemaCache.set(toolName, toolDef as ActionDefinition);
      }
    }
    
 
    
    return actionSchemaCache;
  } catch (error) {
    throw new Error(`Failed to load unified-design.yaml: ${error}`);
  }
}

/**
 * Reconstruct SHAM block text for error context
 */
function reconstructShamBlock(block: Block): string {
  const lines: string[] = [];
  
  // Start line
  lines.push(`#!SHAM [@three-char-SHA-256: ${block.id || 'unknown'}]`);
  
  // Properties
  for (const [key, value] of Object.entries(block.properties || {})) {
    if (key.startsWith('@')) continue; // Skip annotations
    
    if (typeof value === 'string' && value.includes('\n')) {
      // Multi-line value with heredoc
      lines.push(`${key} = <<'EOT_SHAM_${block.id}'`);
      lines.push(value);
      lines.push(`EOT_SHAM_${block.id}`);
    } else {
      // Single line value - use JSON.stringify to handle quotes properly
      lines.push(`${key} = ${JSON.stringify(value)}`);
    }
  }
  
  // End line
  lines.push(`#!END_SHAM_${block.id || 'unknown'}`);
  
  return lines.join('\n');
}

// Re-export functions for consumers
export { validateShamBlock, transformToAction };
=== END FILE: /Users/stuart/repos/clada/proj/comp/sham-action-parser/src/index.ts ===

