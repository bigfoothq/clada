=== START FILE: /Users/stuart/repos/clada/proj/comp/listener/test/integration/listener-workflow-v2.test.ts ===
import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { readFile, writeFile, mkdir, rm } from 'fs/promises';
import { join, dirname } from 'path';
import { fileURLToPath } from 'url';
import { marked } from 'marked';
import { startListener } from '../../src/listener.js';
import type { ListenerHandle } from '../../src/types.js';

const __dirname = dirname(fileURLToPath(import.meta.url));

interface TestCase {
  name: string;
  initialContent: string;
  newContent: string;
  expectedPrepended: string;
  expectedOutput: string;
}

// Helper to normalize timestamps for comparison
function normalizeTimestamp(content: string): string {
  return content.replace(/at \d{1,2}:\d{2}:\d{2}/g, 'at 10:30:00');
}

// Helper to normalize block IDs (abc, wr1, etc) for comparison
function normalizeBlockIds(content: string): string {
  // This is a simplified version - in real tests we'd need to map generated IDs
  return content;
}

// Parse test cases from markdown
async function parseTestCases(): Promise<TestCase[]> {
  const testDataPath = join(__dirname, '../../test-data/integration/listener-workflow-v2.cases.md');
  const markdown = await readFile(testDataPath, 'utf-8');
  
  const tokens = marked.lexer(markdown);
  const testCases: TestCase[] = [];
  let currentTest: Partial<TestCase> | null = null;
  let codeBlocksForCurrentTest: string[] = [];
  
  for (let i = 0; i < tokens.length; i++) {
    const token = tokens[i];
    
    // Test case name (h3)
    if (token.type === 'heading' && token.depth === 3) {
      // Save previous test if complete
      if (currentTest && currentTest.name && codeBlocksForCurrentTest.length === 4) {
        currentTest.initialContent = codeBlocksForCurrentTest[0];
        currentTest.newContent = codeBlocksForCurrentTest[1];
        currentTest.expectedPrepended = codeBlocksForCurrentTest[2];
        currentTest.expectedOutput = codeBlocksForCurrentTest[3];
        testCases.push(currentTest as TestCase);
      }
      
      // Start new test
      currentTest = { name: token.text };
      codeBlocksForCurrentTest = [];
    }
    
    // Collect code blocks (regardless of h4 headings)
    if (token.type === 'code' && currentTest) {
      codeBlocksForCurrentTest.push(token.text);
    }
  }
  
  // Don't forget the last test case
  if (currentTest && currentTest.name && codeBlocksForCurrentTest.length === 4) {
    currentTest.initialContent = codeBlocksForCurrentTest[0];
    currentTest.newContent = codeBlocksForCurrentTest[1];
    currentTest.expectedPrepended = codeBlocksForCurrentTest[2];
    currentTest.expectedOutput = codeBlocksForCurrentTest[3];
    testCases.push(currentTest as TestCase);
  }
  
  return testCases;
}

// Helper to poll for expected content
async function pollForContent(
  filePath: string, 
  check: (content: string) => boolean, 
  timeoutMs: number = 2000
): Promise<string> {
  const startTime = Date.now();
  while (Date.now() - startTime < timeoutMs) {
    try {
      const content = await readFile(filePath, 'utf-8');
      if (check(content)) return content;
    } catch {}
    await new Promise(resolve => setTimeout(resolve, 50));
  }
  throw new Error(`Timeout after ${timeoutMs}ms waiting for expected content`);
}

describe('listener workflow v2', async () => {
  const testCases = await parseTestCases();
  
  for (const testCase of testCases) {
    it(testCase.name, async () => {
      let handle: ListenerHandle | null = null;
      const testDir = `/tmp/t_listener_${testCase.name.toLowerCase().replace(/\s+/g, '_')}`;
      const testFile = join(testDir, 'test.txt');
      const outputFile = join(testDir, '.clada-output-latest.txt');
      
      try {
        // Setup
        await mkdir(testDir, { recursive: true });
        await writeFile(testFile, testCase.initialContent);
        
        // Start listener
        handle = await startListener({ 
          filePath: testFile, 
          debounceMs: 100 
        });
        
        // Wait for initial processing
        await pollForContent(testFile, content => 
          content.includes('=== CLADA RESULTS ===')
        );
        
        // Wait for debounce
        await new Promise(resolve => setTimeout(resolve, 200));
        
        // Write new content
        await writeFile(testFile, testCase.newContent);
        
        // Poll for execution to complete
        await pollForContent(testFile, content => {
          const normalized = normalizeTimestamp(content);
          // Check if the summary section matches expected pattern
          return normalized.includes('üìã Copied to clipboard at 10:30:00') &&
                 normalized.includes('=== CLADA RESULTS ===') &&
                 normalized.includes('=== END ===');
        });
        
        // Verify prepended results
        const actualPrepended = await readFile(testFile, 'utf-8');
        const normalizedActual = normalizeTimestamp(normalizeBlockIds(actualPrepended));
        const normalizedExpected = normalizeTimestamp(normalizeBlockIds(testCase.expectedPrepended));
        
        // For now, just check key elements are present
        expect(normalizedActual).toContain('üìã Copied to clipboard at 10:30:00');
        expect(normalizedActual).toContain('=== CLADA RESULTS ===');
        expect(normalizedActual).toContain('=== END ===');
        expect(normalizedActual).toContain(testCase.newContent);
        
        // Verify output file
        const actualOutput = await readFile(outputFile, 'utf-8');
        const normalizedOutput = normalizeTimestamp(normalizeBlockIds(actualOutput));
        
        expect(normalizedOutput).toContain('üìã Copied to clipboard at 10:30:00');
        expect(normalizedOutput).toContain('=== CLADA RESULTS ===');
        expect(normalizedOutput).toContain('=== OUTPUTS ===');
        
      } finally {
        // Cleanup
        if (handle) {
          await handle.stop();
        }
        await rm(testDir, { recursive: true, force: true });
      }
    });
  }
});
=== END FILE: /Users/stuart/repos/clada/proj/comp/listener/test/integration/listener-workflow-v2.test.ts ===

=== START FILE: /Users/stuart/repos/clada/proj/comp/listener/src/index.ts ===
export { startListener, stopListener } from './listener.js';
export type { ListenerConfig, ListenerHandle, ListenerState } from './types.js';
export { ListenerError } from './errors.js';
=== END FILE: /Users/stuart/repos/clada/proj/comp/listener/src/index.ts ===

=== START FILE: /Users/stuart/repos/clada/proj/comp/listener/src/listener.ts ===
import { watchFile, unwatchFile, Stats } from 'fs';
import { readFile, writeFile, access, constants } from 'fs/promises';
import { dirname, join } from 'path';
import { write as writeToClipboard } from 'clipboardy';

import type { ListenerConfig, ListenerHandle, ListenerState } from './types.js';
import { ListenerError } from './errors.js';
import { Clada } from '../../orch/src/index.js';
import { formatSummary, formatFullOutput } from './formatters.js';
import { computeContentHash } from './utils.js';

// Module-level state for tracking active listeners
const activeListeners = new Map<string, ListenerHandle>();

// Strip prepended summary section if present
function stripSummarySection(content: string): string {
  const marker = '=== END ===';
  const i = content.lastIndexOf(marker);
  return i === -1 ? content : content.slice(i + marker.length).trimStart();
}


// Debounce utility
function debounce<T extends (...args: any[]) => any>(
  func: T,
  wait: number
): T & { cancel: () => void } {
  let timeout: NodeJS.Timeout | null = null;
  
  const debounced = (...args: Parameters<T>) => {
    if (timeout) clearTimeout(timeout);
    timeout = setTimeout(() => {
      func(...args);
    }, wait);
  };
  
  debounced.cancel = () => {
    if (timeout) clearTimeout(timeout);
  };
  
  return debounced as T & { cancel: () => void };
}

// Generate unique ID for listener instance
function generateId(): string {
  return `listener-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
}

// Format clipboard status line
function formatClipboardStatus(success: boolean, timestamp: Date): string {
  const time = timestamp.toLocaleTimeString();
  return success ?
    `üìã Copied to clipboard at ${time}` :
    `‚ùå Clipboard copy failed at ${time}`;
}

// Process file changes
async function processFileChange(filePath: string, state: ListenerState): Promise<void> {
  // Check not already processing
  if (state.isProcessing) return;
  
  try {
    state.isProcessing = true;
    
    // Read file
    const fullContent = await readFile(filePath, 'utf-8');
    
    // Strip summary section for hashing
    const contentForHash = stripSummarySection(fullContent).trim();
    
    // DIAGNOSTIC: Log stripping results
    console.log('\n=== STRIP SUMMARY ===');
    console.log('Original length:', fullContent.length);
    console.log('Stripped length:', contentForHash.length);
    console.log('Stripped content preview:', contentForHash.substring(0, 150).replace(/\n/g, '\\n'));
    console.log('=== END STRIP ===\n');
    
    // Compute hash of content (excluding summary)
    const currentHash = computeContentHash(contentForHash);
    
    // DIAGNOSTIC: Log hash comparison
    console.log('Current hash:', currentHash);
    console.log('Last hash:', state.lastExecutedHash);
    
    // Skip if unchanged
    if (currentHash === state.lastExecutedHash) {
      console.log('Content unchanged, skipping execution');
      return;
    }
    
    // Execute via orchestrator with full file content
    const clada = new Clada({ gitCommit: false });
    const orchResult = await clada.execute(fullContent);
    console.log('Executed', orchResult.executedActions, 'actions');
    
    // Format outputs
    const timestamp = new Date();
    const summary = formatSummary(orchResult, timestamp);
    const fullOutput = formatFullOutput(orchResult);
    
    // Copy to clipboard
    let clipboardSuccess = false;
    try {
      await writeToClipboard(fullOutput);
      clipboardSuccess = true;
    } catch (error) {
      console.error('listener: Clipboard write failed:', error);
    }
    
    // Format clipboard status
    const clipboardStatus = formatClipboardStatus(clipboardSuccess, timestamp);
    
    // Write output file with clipboard status
    const outputContent = clipboardStatus + '\n' + fullOutput;
    await writeFile(state.outputPath, outputContent);
    
    // Prepend to input file with clipboard status
    const prepend = clipboardStatus + '\n' + summary;
    const updatedContent = prepend + '\n' + fullContent;
    await writeFile(filePath, updatedContent);
    
    // Update state
    state.lastExecutedHash = currentHash;
    
  } catch (error) {
    console.error('listener: Error processing file change:', error);
  } finally {
    state.isProcessing = false;
  }
}

export async function startListener(config: ListenerConfig): Promise<ListenerHandle> {
  // Validate config
  if (!config.filePath) {
    throw new Error('listener: filePath is required');
  }
  if (!config.filePath.startsWith('/')) {
    throw new Error('listener: filePath must be absolute');
  }
  if (config.debounceMs !== undefined && config.debounceMs < 100) {
    throw new Error('listener: debounceMs must be at least 100');
  }
  
  // Check file exists
  try {
    await access(config.filePath, constants.F_OK);
  } catch (error) {
    throw new ListenerError('FILE_NOT_FOUND', config.filePath);
  }
  
  // Check not already watching
  if (activeListeners.has(config.filePath)) {
    throw new ListenerError('ALREADY_WATCHING', config.filePath);
  }
  
  // Initialize state
  const state: ListenerState = {
    lastExecutedHash: '',
    isProcessing: false,
    outputPath: join(dirname(config.filePath), config.outputFilename || '.clada-output-latest.txt')
  };
  
  // Set up debounced handler
  const debouncedProcess = debounce(
    () => {
      console.log('Debounced process executing');
      processFileChange(config.filePath, state);
    },
    config.debounceMs || 500
  );
  
  // Start watching
  watchFile(config.filePath, { interval: 500 }, (curr: Stats, prev: Stats) => {
    if (curr.mtime !== prev.mtime) {
      console.log('File change detected, triggering debounced process');
      debouncedProcess();
    }
  });
  
  // Process initial content
  debouncedProcess();
  
  // Create handle
  const handle: ListenerHandle = {
    id: generateId(),
    filePath: config.filePath,
    stop: async () => {
      unwatchFile(config.filePath);
      debouncedProcess.cancel();
      activeListeners.delete(config.filePath);
    }
  };
  
  // Track active listener
  activeListeners.set(config.filePath, handle);
  
  return handle;
}

export async function stopListener(handle: ListenerHandle): Promise<void> {
  await handle.stop();
}
=== END FILE: /Users/stuart/repos/clada/proj/comp/listener/src/listener.ts ===

=== START FILE: /Users/stuart/repos/clada/proj/comp/listener/test-data/integration/listener-workflow-v2.cases.md ===
# Listener Workflow Integration Tests v2

## listener-workflow-v2

### simple-file-write

#### input file

````sh
Just a simple text file.
Nothing special here.
````

#### input file
````sh
Just a simple text file.
Nothing special here.

```sh sham
#!SHAM [@three-char-SHA-256: sf1]
action = "file_write"
path = "/tmp/t_listener_simple/output.txt"
content = "Hello from SHAM!"
#!END_SHAM_sf1
```
````


#### input file
````sh

üìã Copied to clipboard at 10:30:00

=== CLADA RESULTS ===
sf1 ‚úÖ file_write /tmp/t_listener_simple/output.txt
=== END ===

Just a simple text file.
Nothing special here.

```sh sham
#!SHAM [@three-char-SHA-256: sf1]
action = "file_write"
path = "/tmp/t_listener_simple/output.txt"
content = "Hello from SHAM!"
#!END_SHAM_sf1
```
````

#### output file
````sh
üìã Copied to clipboard at 10:30:00

=== CLADA RESULTS ===
sf1 ‚úÖ file_write /tmp/t_listener_simple/output.txt
=== END ===

=== OUTPUTS ===
=== END ===
````

### multiple-actions-mixed-results

#### input file

````sh
Empty file to start.
````

#### input file
````sh
```sh
#!SHAM [@three-char-SHA-256: wr1]
action = "file_write"
path = "/tmp/t_listener_multi/created.txt"
content = "This will succeed"
#!END_SHAM_wr1
```

```sh sham
#!SHAM [@three-char-SHA-256: rd1]
action = "file_read"
path = "/tmp/t_listener_multi/missing.txt"
#!END_SHAM_rd1
```

```sh sham
#!SHAM [@three-char-SHA-256: ex1]
action = "exec"
lang = "bash"
code = "echo 'Hello from bash'"
#!END_SHAM_ex1
```
````

#### input file
````sh
```
üìã Copied to clipboard at 10:30:00

=== CLADA RESULTS ===
wr1 ‚úÖ file_write /tmp/t_listener_multi/created.txt
rd1 ‚ùå file_read /tmp/t_listener_multi/missing.txt - File not found
ex1 ‚úÖ exec bash
=== END ===

Empty file to start.

```sh sham
#!SHAM [@three-char-SHA-256: wr1]
action = "file_write"
path = "/tmp/t_listener_multi/created.txt"
content = "This will succeed"
#!END_SHAM_wr1
```

```sh sham
#!SHAM [@three-char-SHA-256: rd1]
action = "file_read"
path = "/tmp/t_listener_multi/missing.txt"
#!END_SHAM_rd1
```

```sh sham
#!SHAM [@three-char-SHA-256: ex1]
action = "exec"
lang = "bash"
code = "echo 'Hello from bash'"
#!END_SHAM_ex1
```
````

#### output file
````sh
üìã Copied to clipboard at 10:30:00

=== CLADA RESULTS ===
wr1 ‚úÖ file_write /tmp/t_listener_multi/created.txt
rd1 ‚ùå file_read /tmp/t_listener_multi/missing.txt - File not found
ex1 ‚úÖ exec bash
=== END ===

=== OUTPUTS ===

[ex1] exec bash:
stdout:
Hello from bash
=== END ===
````

### parse-error-handling

#### Initial Content
````sh
Testing parse errors.
````

#### New Content
````sh
Testing parse errors.

```sh sham
#!SHAM [@three-char-SHA-256: bad]
action = "file_write"
path = "/tmp/t_listener_parse/test.txt"
content = "missing closing quote
#!END_SHAM_bad
```
````

#### Expected Prepended Results
````sh
üìã Copied to clipboard at 10:30:00

=== CLADA RESULTS ===
bad ‚ùå file_write - Unclosed quoted string
=== END ===

Testing parse errors.

```sh sham
#!SHAM [@three-char-SHA-256: bad]
action = "file_write"
path = "/tmp/t_listener_parse/test.txt"
content = "missing closing quote
#!END_SHAM_bad
```
````

#### Expected Output File
````sh
üìã Copied to clipboard at 10:30:00

=== CLADA RESULTS ===
bad ‚ùå file_write - Unclosed quoted string
=== END ===

=== OUTPUTS ===
=== END ===
````

### no-reexecution-on-same-content

#### Initial Content
````sh
Testing hash-based execution.
````

#### New Content
````sh
Testing hash-based execution.

```sh sham
#!SHAM [@three-char-SHA-256: nc1]
action = "file_write"
path = "/tmp/t_listener_nochange/counter.txt"
content = "1"
#!END_SHAM_nc1
```

Adding a comment outside SHAM blocks.
````

#### Expected Prepended Results
````sh
üìã Copied to clipboard at 10:30:00

=== CLADA RESULTS ===
nc1 ‚úÖ file_write /tmp/t_listener_nochange/counter.txt
=== END ===

Testing hash-based execution.

```sh sham
#!SHAM [@three-char-SHA-256: nc1]
action = "file_write"
path = "/tmp/t_listener_nochange/counter.txt"
content = "1"
#!END_SHAM_nc1
```

Adding a comment outside SHAM blocks.
````

#### Expected Output File
````sh
üìã Copied to clipboard at 10:30:00

=== CLADA RESULTS ===
nc1 ‚úÖ file_write /tmp/t_listener_nochange/counter.txt
=== END ===

=== OUTPUTS ===
=== END ===
````
=== END FILE: /Users/stuart/repos/clada/proj/comp/listener/test-data/integration/listener-workflow-v2.cases.md ===

=== START FILE: /Users/stuart/repos/clada/proj/comp/listener/doc/ABSTRACT.md ===
# File Listener

Watches a file for SHAM blocks, executes them via orchestrator, and prepends results while managing output to clipboard and separate file.

## Overview

The listener component provides continuous monitoring of a designated input file for SHAM action blocks. When file content changes (excluding any prepended results section), it executes all SHAM blocks through the orchestrator component and manages the output flow. Results are formatted as a summary prepended to the input file, with full output written to a companion file and copied to clipboard.

The component handles the complete lifecycle: detecting changes via file system events, parsing content to extract SHAM blocks, determining which blocks are new based on content hashing, executing actions in order, formatting results into summary and detailed views, and coordinating the three output destinations (input file prepend, output file, clipboard). It includes debouncing to handle rapid file saves and provides clear visual feedback when operations complete.

The design prioritizes developer experience with clear status indicators, handles common failure modes gracefully (permission errors, clipboard failures), and maintains a simple state model tracking only the hash of previously executed blocks.
=== END FILE: /Users/stuart/repos/clada/proj/comp/listener/doc/ABSTRACT.md ===

=== START FILE: /Users/stuart/repos/clada/proj/comp/listener/doc/API.md ===
# Component: listener

## Component Type
standard

## Dependencies
[Provisional - updated via STOP protocol when implementation reveals actual needs]

```yaml
dependencies:
  proj/comp/orch:                                          # [IMPLEMENTED]
    functions: [execute]
    types: [OrchestratorResult]
  
  node:fs/promises:
    functions: [readFile, writeFile]
  
  node:fs:
    functions: [watchFile, unwatchFile]
    types: [Stats]
  
  node:path:
    functions: [dirname, join]
  
  node:crypto:
    functions: [createHash]
  
  external/clipboardy:
    functions: [write as writeToClipboard]
```

## Exports

```yaml
exports:
  functions: [startListener, stopListener]
  types: [ListenerConfig, ListenerHandle, ListenerState]
  classes:
    ListenerError:
      extends: Error
```

### startListener
- **Signature**: `startListener(config: ListenerConfig) -> Promise<ListenerHandle>`
- **Purpose**: Begin watching file for SHAM blocks and executing them.
- **Throws**: `ListenerError` when file doesn't exist or can't be accessed
- **Test-data**: `test-data/startListener.json` [PLANNED]

### stopListener
- **Signature**: `stopListener(handle: ListenerHandle) -> Promise<void>`
- **Purpose**: Stop watching file and clean up resources.
- **Test-data**: `test-data/stopListener.json` [PLANNED]

## Types

### ListenerConfig
```typescript
{
  filePath: string           // Absolute path to watch
  debounceMs?: number        // Milliseconds to wait before processing (default: 500)
  outputFilename?: string    // Name for output file (default: ".clada-output-latest.txt")
}
```

### ListenerHandle
```typescript
{
  id: string                 // Unique listener instance ID
  filePath: string           // Path being watched
  stop: () => Promise<void>  // Method to stop this listener
}
```

### ListenerState
```typescript
{
  lastExecutedHash: string   // SHA-256 of previously executed SHAM content
  isProcessing: boolean      // Currently executing actions
  outputPath: string         // Full path to output file
}
```

### ListenerError
```typescript
class ListenerError extends Error {
  code: 'FILE_NOT_FOUND' | 'ACCESS_DENIED' | 'ALREADY_WATCHING'
  path: string
}
```

## Internal Functions
[To be discovered during implementation]

### processFileChange
- **Signature**: `processFileChange(filePath: string, state: ListenerState) -> Promise<void>`
- **Purpose**: Read file, hash content after summary, execute if changed.

### stripSummarySection
- **Signature**: `stripSummarySection(content: string) -> string`
- **Purpose**: Remove prepended results section if present.

### computeContentHash
- **Signature**: `computeContentHash(content: string) -> string`
- **Purpose**: Generate SHA-256 hash of content for comparison.

### formatSummary
- **Signature**: `formatSummary(results: OrchestratorResult, timestamp: Date) -> string`
- **Purpose**: Create the summary text block for prepending.

### formatFullOutput
- **Signature**: `formatFullOutput(results: OrchestratorResult) -> string`
- **Purpose**: Create detailed output including action outputs.

### updateFileWithClipboardStatus
- **Signature**: `updateFileWithClipboardStatus(filePath: string, timestamp: Date) -> Promise<void>`
- **Purpose**: Replace first line with clipboard success indicator.
=== END FILE: /Users/stuart/repos/clada/proj/comp/listener/doc/API.md ===

=== START FILE: /Users/stuart/repos/clada/proj/comp/listener/doc/ARCH.md ===
# Listener Architecture

## Design Philosophy

**Minimal State, Maximum Reliability**: Track only what's necessary (content hash), handle failures gracefully, provide clear feedback. No complex state machines or recovery logic.

## Key Design Decisions

### File Watching Strategy
- Use `fs.watchFile` with polling (more reliable than fs.watch)
- Poll interval: 500ms default
- Stat-based change detection
- Single watcher per file (error if duplicate)

**Rationale**: fs.watch has platform inconsistencies. Polling is battery-hungry but reliable for single-file monitoring.

### Content Hashing
- Hash file content after stripping any prepended summary section
- Use SHA-256 of content after first "=== END ===" line
- If no summary section, hash entire content
- Hash comparison determines execution

**Note**: Parse errors won't trigger re-execution when fixed (content unchanged).

### Debouncing
- File change starts debounce timer
- Subsequent changes reset timer
- Only process after quiet period
- Default: 500ms

**Rationale**: Editors often write multiple times. Prevents redundant execution during typing.

### Output Coordination

**Three destinations, specific order**:
1. Write `.clada-output-latest.txt` (same directory)
2. Prepend summary to input file (with blank first line)
3. Copy full output to clipboard
4. Update first line with clipboard status

**Failure handling**:
- Output file fails: Continue, log error
- Prepend fails: Abort (can't update user's file)
- Clipboard fails: Note in first line
- All operations independent

### Summary Format
```
[blank line for clipboard status]
=== CLADA RESULTS ===
{id} ‚úÖ {action} {primary_param}
{id} ‚ùå {action} {primary_param} - {error_summary}
=== END ===
```

example after copy:

```
üìã Copied to clipboard at 10:32:45
=== CLADA RESULTS ===
c8i ‚úÖ file_write /path/to/file.md
qb2 ‚ùå file_write /path/to/other.rs - Permission denied
v84 ‚úÖ exec javascript - 17 lines
=== END ===
```

### Full Output Format
```
=== CLADA RESULTS ===
[same as summary]
=== OUTPUTS ===
[{id}] {action} {primary_param}:
{output content}

[{id}] {action} {primary_param}:
{output content}
=== END ===
```

### Output Display Rules
Read from unified-design.yaml per action:
- `output_display: always` - Include in OUTPUTS section
- `output_display: never` - Summary only
- `output_display: conditional` - Check return_output parameter

### Truncation
- 50KB limit per action output
- UTF-8 aware truncation
- Show first 25KB + last 25KB
- Clear truncation message

### Race Condition Acceptance
**Problem**: User edits during processing
**Solution**: Document-only. No locking or conflict resolution.
**Rationale**: Toy project, complex solutions not warranted.

### Process Lifecycle
1. **Watch** - fs.watchFile on config.filePath
2. **Detect** - mtime change triggers debounced handler
3. **Read** - Load file content
4. **Strip** - Remove prepended summary section if present
5. **Hash** - Compute hash of remaining content
6. **Compare** - Skip if hash matches lastExecutedHash
7. **Execute** - Call orchestrator.execute() with full file
8. **Format** - Generate summary and full output from results
9. **Write** - Output file, prepend summary, clipboard
10. **Update** - Store new hash

## Error Messages

Formatted for developer clarity:
- "listener: File not found '{path}'"
- "listener: Already watching '{path}'"
- "listener: Permission denied writing output '{path}'"
- "listener: Clipboard write failed"


=== END FILE: /Users/stuart/repos/clada/proj/comp/listener/doc/ARCH.md ===

=== START FILE: /Users/stuart/repos/clada/package.json ===
{
  "name": "clada",
  "version": "0.1.0",
  "description": "Common LLM Actions Desktop Actuator",
  "type": "module",
  "engines": {
    "node": ">=20.0.0"
  },
  "scripts": {
    "build": "tsc --noEmit",
    "dev": "tsx watch proj/src/index.ts",
    "start": "tsx proj/src/index.ts",
    "test": "vitest run",
    "test:watch": "vitest watch",
    "test:run": "vitest run",
    "test:debug": "vitest run --reporter=verbose --no-coverage",
    "test:handles": "node --expose-gc ./node_modules/.bin/vitest run --reporter=verbose --no-coverage",
    "typecheck": "tsc --noEmit",
    "lint": "eslint proj/**/*.ts",
    "lint:fix": "eslint proj/**/*.ts --fix"
  },
  "dependencies": {
    "clipboardy": "^4.0.0",
    "js-yaml": "^4.1.0",
    "marked": "^12.0.0",
    "nesl-js": "github:nesl-lang/nesl-js"
  },
  "devDependencies": {
    "@types/js-yaml": "^4.0.9",
    "@types/node": "^20.19.9",
    "@typescript-eslint/eslint-plugin": "^7.0.0",
    "@typescript-eslint/parser": "^7.0.0",
    "eslint": "^8.56.0",
    "ts-node": "^10.9.2",
    "tsx": "^4.7.0",
    "typescript": "^5.8.3",
    "vitest": "^1.2.0"
  },
  "keywords": [
    "llm",
    "actions",
    "filesystem",
    "sham"
  ],
  "author": "",
  "license": "MIT"
}

=== END FILE: /Users/stuart/repos/clada/package.json ===

=== START FILE: /Users/stuart/repos/clada/proj/comp/orch/doc/API.md ===
# Component: clada

## Component Type
standard

## Dependencies

```yaml
dependencies:
  proj/comp/sham-action-parser:  # [IMPLEMENTED]
    functions: [parseShamResponse]
    types: [ParseResult, CladaAction, ParseError, ValidationResult, TransformError]
  
  proj/comp/fs-ops:              # [PARTIALLY IMPLEMENTED]
    functions: [executeFileOperation]
    types: [FileOpResult]
    classes:
      FileOpError:
        extends: Error
  
  proj/comp/exec:                # [PLANNED]
    functions: [executeCommand]
    types: [ExecResult]
  
  proj/comp/git-tx:              # [PLANNED - v1.2]
    functions: [ensureCleanRepo, commitChanges]
    types: [GitError]
  
  proj/comp/context:             # [PLANNED]
    functions: [addPath, removePath, listPaths, clearContext]
    types: [ContextError]
  
  external/nesl-js:
    functions: [parseSham]
    types: [Block, ParseResult, ParseError]
```

## Exports

```yaml
exports:
  classes:
    Clada:
      constructor: [options?: CladaOptions]
      methods: [execute]
  types: 
    - ExecutionResult
    - ActionResult  
    - CladaOptions
  # Note: ParseError is re-exported from sham-action-parser
```

### Clada (class)
- **Purpose**: Main orchestrator executing SHAM blocks from LLM output
- **Constructor**: `new Clada(options?: CladaOptions)`
- **State**: Maintains working directory and context set across execute() calls

### execute
- **Signature**: `async execute(llmOutput: string): Promise<ExecutionResult>`
- **Purpose**: Parse and execute all SHAM blocks in LLM output, commit results
- **Process**: 
  1. Parse SHAM blocks
  2. Convert to actions
  3. Execute all valid actions
  4. (v1.2: Git commit with summary)
- **Throws**: Never - all errors captured in ExecutionResult
- **Test-data**: `test-data/execute/basic-operations.md` [IMPLEMENTED]

### ExecutionResult (type)
```typescript
interface ExecutionResult {
  success: boolean              // False if any action failed
  totalBlocks: number          // Count of SHAM blocks found
  executedActions: number      // Count of actions attempted
  results: ActionResult[]      // All execution results
  parseErrors: ParseError[]    // SHAM parsing errors
  fatalError?: string         // System failure (v1.2: will include git errors)
}
```

### ActionResult (type)
```typescript
interface ActionResult {
  seq: number                  // Execution order
  blockId: string             // SHAM block ID
  action: string              // Action type
  params: Record<string, any> // Input parameters
  success: boolean
  error?: string              // Error message if failed
  data?: any                  // Action-specific output
}
```

### ParseError (type)
```typescript
interface ParseError {
  blockId?: string            // If error is block-specific
  error: ShamError            // From parser
}
```

### CladaOptions (type)
```typescript
interface CladaOptions {
  repoPath?: string           // Default: process.cwd()
  gitCommit?: boolean         // v1.2 feature - Default: true
}
```

## Internal Architecture

### Execution Flow
```
execute(llmOutput)
  ‚Üí parseSHAM(llmOutput) ‚Üí ShamParseResult
  ‚Üí for each valid block:
    ‚Üí convertToActions(block) ‚Üí CladaAction[]
    ‚Üí for each action:
      ‚Üí route to appropriate executor
      ‚Üí capture result
  ‚Üí commitChanges(results)
  ‚Üí return ExecutionResult
```

### Action Routing
- file_* ‚Üí fs-ops
- dir_* ‚Üí fs-ops
- exec ‚Üí exec
- context_* ‚Üí context
- ls, grep, glob ‚Üí fs-ops (read operations)

### Error Handling
- Parser errors: Skip block, record error
- Conversion errors: Skip action, record error
- Execution errors: Continue execution, record error
- Git errors: Fatal, abort with fatalError
=== END FILE: /Users/stuart/repos/clada/proj/comp/orch/doc/API.md ===

=== START FILE: /Users/stuart/repos/clada/proj/comp/orch/doc/ARCH.md ===
# Clada Architecture


IMPORTANT TOOL TESTING NOTES:

- for test specific clada tools, each tool must get its own test case file, for easy visibility into which tools have been implemented and tested yet.
- aka `proj/comp/fs-ops/test-data/integration/file_delete.cases.md`

## Core Design Decisions

### Transaction Model
- **No automatic rollback** - All operations commit, including failures
- **Failures are data** - LLM needs failure feedback for next steps
- **Forward-only progress** - Cheaper than regenerating responses
- **Manual rollback only** - Human-initiated via git commands
- **Boundary**: One git commit per `execute()` call
- **API**: Explicit transaction management (details TBD)

### SHAM Processing Pipeline
1. SHAM parser (external npm) ‚Üí AST
2. AST ‚Üí Action objects (sham-ast-converter)
3. Actions ‚Üí Execution ‚Üí Results

### SHAM AST Structure
```typescript
interface ShamParseResult {
  blocks: ShamBlock[]
  errors: ShamError[]
}

interface ShamBlock {
  id: string           // 3-char SHA-256
  properties: {
    action: string     // Maps to tool name (e.g., "file_write")
    [key: string]: any // Tool-specific parameters
  }
  startLine: number
  endLine: number
}

interface ShamError {
  code: string         // e.g., "DUPLICATE_KEY"
  line: number
  column: number
  length: number
  blockId: string
  content: string
  context: string
  message: string
}
```

### Error Propagation Strategy
- **Parser errors**: Skip blocks with parser errors, execute valid blocks only
- **Validation errors**: Skip invalid actions, execute valid ones
- **Execution errors**: Continue with remaining actions
- **Result**: Complete execution log with successes and failures

### Action Mapping
- SHAM `action` property maps directly to tool names from unified-design.yaml
- Use canonical names: `file_write`, `exec`, etc.

### Context Management
- **V1**: Simple `Set<string>` of file paths
- **Storage**: In-memory only, no persistence across sessions
- **V2 Future**: Sub-file references (lines, functions, sections)

### Execution Model
- **Synchronous**: All operations block until complete
- **CWD Management**: Session-based working directory
  - Default: Repository root
  - Each exec can override with `cwd` parameter
  - CWD persists within session, not across transactions
- **Results Format**: Flat array with sequence numbers
```typescript
interface ActionResult {
  seq: number          // Execution order
  blockId: string      // SHAM block ID
  action: string       // Action type
  params: any          // Input parameters
  success: boolean
  error?: string       // Error message if failed
  data?: any           // Action-specific output (stdout, content, etc.)
}
```

### Security Model (V1)
- **None**: Full filesystem access
- **No validation**: Any path allowed
- **No sandboxing**: Direct execution
- **V2 Future**: Path allowlisting per unified-design.yaml. FOR THIS REASON all fs stuff should immediately be implemented using our fs wrapper functions so this whitelisting/blacklisting is easy to implment in the future.

## Component Structure
```
clada/
‚îú‚îÄ‚îÄ proj/
‚îÇ   ‚îú‚îÄ‚îÄ comp/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ sham-ast-converter/  # AST ‚Üí Actions
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ fs-ops/              # File/directory operations
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ exec/                # Command execution
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ git-tx/              # Git transaction management
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ context/             # Working set management
‚îÇ   ‚îî‚îÄ‚îÄ doc/
‚îÇ       ‚îú‚îÄ‚îÄ API.md               # Main orchestrator API
‚îÇ       ‚îú‚îÄ‚îÄ ARCH.md              # This document
‚îÇ       ‚îî‚îÄ‚îÄ ABSTRACT.md          # Project overview
```

## Implementation Priorities
1. `sham-ast-converter` - Cannot test without this
2. `fs-ops` - Core functionality
3. `exec` - Command execution
4. `git-tx` - Transaction wrapper
5. `context` - Working set (may be simple enough to inline)

## Open Questions

### Critical
1. **SHAM parser package**: `nesl-js` from `github:nesl-lang/nesl-js`
   - Import: `const { parseSHAM } = require('nesl-js')`
2. **Transaction API**: Single `execute()` method processes SHAM block array

### Design
1. **Parser error handling**: Execute blocks with parser errors or skip?
2. **Git conflict handling**: How to handle conflicts during manual rollback?
3. **Concurrent access**: Multiple clada instances on same repo?
4. **Partial failure behavior**: Continue executing after first failure or abort?

### Future
1. **Context references**: Syntax for line ranges and functions
2. **Execution isolation**: Container/VM strategy for V2
3. **Streaming results**: Return results as actions complete or batch at end?

## Design Rationale

### Why No Automatic Rollback
Traditional transaction systems rollback on failure to maintain consistency. Clada explicitly rejects this because:
1. **LLM responses are expensive** - Regenerating costs time and money
2. **Partial success is informative** - LLM learns from failures
3. **Git preserves history** - Can always manually revert
4. **Forward progress over perfection** - Incremental improvement model

### Why Synchronous Execution
1. **Deterministic results** - LLM needs to know exact outcomes
2. **Sequential dependencies** - Later actions may depend on earlier ones
3. **Simpler implementation** - No async state management
4. **Git compatibility** - Git operations are inherently synchronous

### Why In-Memory Context
1. **Session isolation** - Each LLM conversation is independent
2. **No persistence complexity** - No file format versioning
3. **Git is the source of truth** - Files on disk matter, not context
4. **Quick reset** - New session = clean slate
=== END FILE: /Users/stuart/repos/clada/proj/comp/orch/doc/ARCH.md ===

=== START FILE: /Users/stuart/repos/clada/replacer/replacer_llm_instructions.md ===
coding style guide:  TDD.  self documenting code.  every api  function name should make it super obvious who is doing what and why

WOL = "words or less, please"

keep the docs as lean

refactor code to make it smaller whenever possible.  DRY.

IMPORTANT:  do not generate edit instructions unless specifically asked to.  not necessary when just discussing and brainstorming

- all code functions and classes or large (10 lines of code or more?) need code comments to cocnisely and lcearly describe what they're doing and why and how

IMPORTANT: 

whenever you generate new code, use the following format.  dont just generate a standalone artifact.  when generating one or multiple new files, use the OVERWRITE pattern shown below 

For each specific edit that needs to happen, list a brief explanation for the change, list file name, and then explicitly make it clear what the target text is that need to be changed, and then the replacement text is that will replace it. Each of those blocks of text or code need to be explicit verbatim character by character Perfect matches for the intended text.  be sure to put the filenames and expalanations on their own lines for easy human reading even in output format.  like paragraph breaks before and after so thye're on their own lines even when not in code blocks.  use this format below exactly. note that the OVERWRITE style block can be used to create new files and its parent dirs.

make the search find text or code blocks as small as possible to still be unique identifiers for what needs to be changed in the underlying files 

for the file path, use as much of the path that you know of.  should be as specific as you can accurately be.  

make sure that file paths include the current main project dir

<<<EXPLANATION>>>

this is why the change should happen

<<<FILE>>>

package/replacer_demo_src/main.py

<<<SEARCH>>>
def old_function():
   x = 1
   y = 2
   return x + y
<<<REPLACE>>>
def new_function():
   result = 3
   return result
<<<END>>>




<<<EXPLANATION>>>

this is why this change should happen

<<<FILE>>>
july/coding/bobstuff/react/config/settings.json
<<<OVERWRITE>>>
{
   "debug": true,
   "port": 8080
}
<<<END>>>

NOTE: if you want to remove a section of code, your replace block must contain a blank line and a space:


<<<EXPLANATION>>>

remove the search code

<<<FILE>>>

package/replacer_demo_src/main.py

<<<SEARCH>>>
def old_function():
   x = 1
   y = 2
   return x + y
<<<REPLACE>>>
 
<<<END>>>

see how the REPLACE block can never be totally empty. must contain blank line and whitespace (space(s)) too

IMPORTANT:  each edit item must list its associated FILE.  each SEARCH/REPLACE or OVERWRITE etc block must be immediately preceeded by the respective file 

$$$$$$$$$$$$$

Prioritize substance, clarity, and depth. Challenge all my proposals, designs, and conclusions as hypotheses to be tested. Sharpen follow-up questions for precision, surfacing hidden assumptions, trade offs, and failure modes early. Default to terse, logically structured, information-dense responses unless detailed exploration is required. Skip unnecessary praise unless grounded in evidence. Explicitly acknowledge uncertainty when applicable. Always propose at least one alternative framing. Accept critical debate as normal and preferred. Treat all factual claims as provisional unless cited or clearly justified. Cite when appropriate. Acknowledge when claims rely on inference or incomplete information. Favor accuracy over sounding certain.

check anything online when it feels relevant.  good to compare our thoughts/assumptions with what other people are actually doing and thinking

when asked to share your thoughts (like if user says "wdyt"), then walk it out and talk it out gradually, incrementally, slowly, and thoughtfully.  challenge me so we can succeed overall

dont fall into the trap of equating "implementation" with "low-level".  implementation decisions can be high-level when they affect the system's fundamental behavior

IMPORTANT EDIT INSTRUCTIONS NOTE:

- always use full absolute file paths for edit instructions

- to delete a file, share bash commands with the user in your response.  do not use edit instructions to delete a file


=== END FILE: /Users/stuart/repos/clada/replacer/replacer_llm_instructions.md ===

