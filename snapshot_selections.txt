=== START FILE: /Users/stuart/repos/clada/use-listener/test-listener-live.ts ===
#!/usr/bin/env tsx

import { startListener, stopListener } from '../proj/comp/listener/src/index.js';
import { writeFile } from 'fs/promises';
import { join } from 'path';

const TEST_FILE = join(process.cwd(), 'use-listener', 'my-test-commands.md');

async function main() {
  // Create initial test file if it doesn't exist
  try {
    await writeFile(TEST_FILE, `# Test Commands

Try adding SHAM blocks below this line:

\`\`\`sh sham
#!SHAM [@three-char-SHA-256: abc]
action = "ls"
path = "."
#!END_SHAM_abc
\`\`\`

`, { flag: 'wx' }); // wx = write only if doesn't exist
    console.log(`Created test file: ${TEST_FILE}`);
  } catch (e) {
    console.log(`Using existing test file: ${TEST_FILE}`);
  }

  // Start the listener
  console.log('Starting listener...');
  const handle = await startListener({
    filePath: TEST_FILE,
    debounceMs: 500,
    outputFilename: '.my-test-output.txt',
    debug: true
  });

  console.log(`
üéß Listener started!
üìù Edit file: ${TEST_FILE}
üìã Output will be copied to clipboard
üìÑ Full output saved to: .my-test-output.txt

Press Ctrl+C to stop
`);

  // Handle graceful shutdown
  process.on('SIGINT', async () => {
    console.log('\n\nStopping listener...');
    await stopListener(handle);
    process.exit(0);
  });

  // Keep process alive
  await new Promise(() => { });
}

main().catch(console.error);
=== END FILE: /Users/stuart/repos/clada/use-listener/test-listener-live.ts ===

=== START FILE: /Users/stuart/repos/clada/use-listener/my-test-commands.md ===
üìã Copied to clipboard

=== CLADA RESULTS ===
=== END ===


```sh sham
#!SHAM [@three-char-SHA-256: pe]
action = "exec"
lang = "bash"
code = "echo 'test'" extra stuff
#!END_SHAM_pe
=== END FILE: /Users/stuart/repos/clada/use-listener/my-test-commands.md ===

=== START FILE: /Users/stuart/repos/clada/proj/comp/listener/src/formatters.ts ===
import type { OrchestratorResult } from '../../orch/src/types.js';

// export function formatSummary(orchResult: OrchestratorResult, timestamp: Date): string {
//   const lines = ['', '=== CLADA RESULTS ==='];
  
//   // Add execution results
//   if (orchResult.results) {
//     for (const result of orchResult.results) {
//       const icon = result.success ? '‚úÖ' : '‚ùå';
//       const primaryParam = getPrimaryParamFromResult(result);
      
//       if (result.success) {
//         lines.push(`${result.blockId} ${icon} ${result.action} ${primaryParam}`.trim());
//       } else {
//         lines.push(`${result.blockId} ${icon} ${result.action} ${primaryParam} - ${getErrorSummary(result.error)}`.trim());
//       }
//     }
//   }
  
//   // Add parse errors - group by blockId
//   if (orchResult.parseErrors) {
//     const errorsByBlock = new Map<string, any[]>();
    
//     for (const error of orchResult.parseErrors) {
//       const blockId = error.blockId || 'unknown';
//       if (!errorsByBlock.has(blockId)) {
//         errorsByBlock.set(blockId, []);
//       }
//       errorsByBlock.get(blockId)!.push(error);
//     }
    
//     // Format grouped errors
//     for (const [blockId, errors] of errorsByBlock) {
//       const firstError = errors[0];
//       const action = firstError.action || 'parse';
//       const lineInfo = firstError.blockStartLine ? `, line ${firstError.blockStartLine}` : '';
      
//       if (errors.length === 1) {
//         // Single error - simple format
//         lines.push(`${blockId} ‚ùå ${action}${lineInfo} - ${firstError.errorType}: ${firstError.message}`);
//       } else {
//         // Multiple errors - list them
//         lines.push(`${blockId} ‚ùå ${action}${lineInfo} - ${errors.length} errors:`);
//         const uniqueMessages = [...new Set(errors.map(e => `  ${e.errorType}: ${e.message}`))];
//         lines.push(...uniqueMessages);
//       }
//     }
//   }
  
//   lines.push('=== END ===', '');
//   return lines.join('\n');
// }


export function formatSummary(orchResult: OrchestratorResult, timestamp: Date): string {
  const lines = ['', '=== CLADA RESULTS ==='];
  
  // DEBUG: Log raw orchestrator result for parse errors
  if (orchResult.parseErrors && orchResult.parseErrors.length > 0) {
    // console.log('DEBUG: Raw parseErrors:', JSON.stringify(orchResult.parseErrors, null, 2));
  }
  
  // Add execution results
  if (orchResult.results) {
    for (const result of orchResult.results) {
      const icon = result.success ? '‚úÖ' : '‚ùå';
      const primaryParam = getPrimaryParamFromResult(result);
      
      if (result.success) {
        lines.push(`${result.blockId} ${icon} ${result.action} ${primaryParam}`.trim());
      } else {
        lines.push(`${result.blockId} ${icon} ${result.action} ${primaryParam} - ${getErrorSummary(result.error)}`.trim());
      }
    }
  }
  
  // Add parse errors - group by blockId
  if (orchResult.parseErrors) {
    const errorsByBlock = new Map<string, any[]>();
    
    // Group errors by blockId
    for (const error of orchResult.parseErrors) {
      const blockId = error.blockId || 'unknown';
      if (!errorsByBlock.has(blockId)) {
        errorsByBlock.set(blockId, []);
      }
      errorsByBlock.get(blockId)!.push(error);
    }
    
    // Format grouped errors
    for (const [blockId, errors] of errorsByBlock) {
      const firstError = errors[0];
      const action = firstError.action || '-';
      const lineInfo = firstError.blockStartLine ? ` (line ${firstError.blockStartLine})` : '';
      
      // Pad action to 10 characters for alignment
      const paddedAction = action.padEnd(10);
      
      if (errors.length === 1) {
        // Single error
        lines.push(`${blockId} ‚ùå ${paddedAction} ERROR: ${firstError.message}${lineInfo}`);
      } else {
        // Multiple errors - count unique messages
        const messageCount = new Map<string, number>();
        for (const error of errors) {
          const msg = error.message;
          messageCount.set(msg, (messageCount.get(msg) || 0) + 1);
        }
        
        // First line shows total count
        lines.push(`${blockId} ‚ùå ${paddedAction} ERROR: ${errors.length} syntax errors${lineInfo}`);
        
        // Sub-bullets for each unique error type
        const indent = ' '.repeat(20); // Align with ERROR: column
        for (const [msg, count] of messageCount) {
          if (count > 1) {
            lines.push(`${indent}- ${msg} (${count} occurrences)`);
          } else {
            lines.push(`${indent}- ${msg}`);
          }
        }
      }
    }
  }
  
  lines.push('=== END ===', '');
  return lines.join('\n');
}

function getPrimaryParamFromResult(result: any): string {
  if (!result.params) return '';
  if (result.params.path) return result.params.path;
  if (result.params.paths) {
    const paths = result.params.paths.trim().split('\n').filter((p: string) => p.trim());
    return `(${paths.length} files)`;
  }
  if (result.params.pattern) return result.params.pattern;
  if (result.params.lang) return result.params.lang;
  if (result.params.old_path) return result.params.old_path;
  return '';
}

function getErrorSummary(error?: string): string {
  if (!error) return 'Unknown error';
  
  // Extract key error info
  if (error.includes('File not found')) return 'File not found';
  if (error.includes('no such file or directory')) return 'File not found';
  if (error.includes('Permission denied')) return 'Permission denied';
  if (error.includes('Output too large')) return error; // Keep full message
  
  // For other errors, take first part before details
  const match = error.match(/^[^:]+:\s*([^'(]+)/);
  if (match) return match[1].trim();
  
  return error.split('\n')[0]; // First line only
}

/**
 * Format file read output in a human-readable way
 */
function formatFileReadOutput(result: any): string[] {
  const lines: string[] = [];
  
  if (result.action === 'file_read') {
    // Simple file read - data contains { path, content }
    const path = result.data.path || result.params?.path || 'unknown';
    lines.push(`=== START FILE: ${path} ===`);
    lines.push((result.data.content !== undefined ? result.data.content : result.data) || '[empty file]');
    lines.push(`=== END FILE: ${path} ===`);
  } else if (result.action === 'file_read_numbered') {
    // Numbered file read - data contains { path, content } where content has line numbers
    const path = result.data.path || result.params?.path || 'unknown';
    lines.push(`=== START FILE: [numbered] ${path} ===`);
    lines.push((result.data.content !== undefined ? result.data.content : result.data) || '[empty file]');
    lines.push(`=== END FILE: [numbered] ${path} ===`);
  } else if (result.action === 'files_read') {
    // Multiple files read - data contains { paths: string[], content: string[] }
    // Each element in content array corresponds to the file at the same index in paths
    if (result.data.paths && result.data.content) {
      lines.push(`Reading ${result.data.paths.length} files:`);
      
      // List all files first
      for (const path of result.data.paths) {
        lines.push(`- ${path}`);
      }
      
      // Add blank line before file contents
      lines.push('');
      
      // Format each file's content with START/END markers
      for (let i = 0; i < result.data.paths.length; i++) {
        const path = result.data.paths[i];
        const content = result.data.content[i];
        
        lines.push(`=== START FILE: ${path} ===`);
        lines.push(content || '[empty file]');
        lines.push(`=== END FILE: ${path} ===`);
        
        // Add blank line between files (except after the last one)
        if (i < result.data.paths.length - 1) {
          lines.push('');
        }
      }
    } else {
      // Fallback for unexpected format
      lines.push(`Reading 0 files:`);
    }
  }
  
  return lines;
}

export function formatFullOutput(orchResult: OrchestratorResult): string {
  const lines = ['=== CLADA RESULTS ==='];
  
  // Add execution results
  if (orchResult.results) {
    for (const result of orchResult.results) {
      const icon = result.success ? '‚úÖ' : '‚ùå';
      const primaryParam = getPrimaryParamFromResult(result);
      
      if (result.success) {
        lines.push(`${result.blockId} ${icon} ${result.action} ${primaryParam}`.trim());
      } else {
        lines.push(`${result.blockId} ${icon} ${result.action} ${primaryParam} - ${getErrorSummary(result.error)}`.trim());
      }
    }
  }
  
  // Add parse errors - group by blockId
  if (orchResult.parseErrors) {
    const errorsByBlock = new Map<string, any[]>();
    
    // Group errors by blockId
    for (const error of orchResult.parseErrors) {
      const blockId = error.blockId || 'unknown';
      if (!errorsByBlock.has(blockId)) {
        errorsByBlock.set(blockId, []);
      }
      errorsByBlock.get(blockId)!.push(error);
    }
    
    // Format grouped errors
    for (const [blockId, errors] of errorsByBlock) {
      const firstError = errors[0];
      const action = firstError.action || '-';
      const lineInfo = firstError.blockStartLine ? ` (line ${firstError.blockStartLine})` : '';
      
      // Pad action to 10 characters for alignment
      const paddedAction = action.padEnd(10);
      
      if (errors.length === 1) {
        // Single error
        lines.push(`${blockId} ‚ùå ${paddedAction} ERROR: ${firstError.message}${lineInfo}`);
      } else {
        // Multiple errors - count unique messages
        const messageCount = new Map<string, number>();
        for (const error of errors) {
          const msg = error.message;
          messageCount.set(msg, (messageCount.get(msg) || 0) + 1);
        }
        
        // First line shows total count
        lines.push(`${blockId} ‚ùå ${paddedAction} ERROR: ${errors.length} syntax errors${lineInfo}`);
        
        // Sub-bullets for each unique error type
        const indent = ' '.repeat(20); // Align with ERROR: column
        for (const [msg, count] of messageCount) {
          if (count > 1) {
            lines.push(`${indent}- ${msg} (${count} occurrences)`);
          } else {
            lines.push(`${indent}- ${msg}`);
          }
        }
      }
    }
  }
  
  lines.push('=== END ===', '', '=== OUTPUTS ===');
  
  // Add outputs for successful actions based on output_display rules
  if (orchResult.results) {
    for (const result of orchResult.results) {
      if (result.success && result.data && shouldShowOutput(result.action, result.params)) {
        const primaryParam = getPrimaryParamFromResult(result);
        // For file read operations, don't include path in header since it's shown in the formatted output
        const includeParam = !['file_read', 'file_read_numbered', 'files_read'].includes(result.action);
        const header = (primaryParam && includeParam)
          ? `[${result.blockId}] ${result.action} ${primaryParam}:`
          : `[${result.blockId}] ${result.action}:`;
        lines.push('', header);
        
        // Special formatting for file read operations
        if (['file_read', 'file_read_numbered', 'files_read'].includes(result.action)) {
          const formattedOutput = formatFileReadOutput(result);
          lines.push(...formattedOutput);
        } else if (typeof result.data === 'string') {
          lines.push(result.data.trimEnd());
        } else if (result.data.stdout || result.data.stderr) {
          if (result.data.stdout) {
            lines.push(`stdout:\n${result.data.stdout.trimEnd()}`);
          }
          if (result.data.stderr) {
            lines.push(`stderr:\n${result.data.stderr.trimEnd()}`);
          }
        } else {
          lines.push(JSON.stringify(result.data, null, 2));
        }
      }
    }
  }
  
  lines.push('=== END ===');
  return lines.join('\n');
}

/**
 * Check if output should be displayed for an action based on unified-design.yaml rules.
 * This is a simplified check - the real implementation would load from unified-design.yaml.
 */
function shouldShowOutput(action: string, params?: any): boolean {
  // Actions with output_display: never
  const neverShowOutput = ['file_write', 'file_replace_text', 'file_replace_all_text', 'file_append', 'file_delete', 'file_move', 'dir_create', 'dir_delete'];
  if (neverShowOutput.includes(action)) {
    return false;
  }
  
  // Actions with output_display: always
  const alwaysShowOutput = ['file_read', 'file_read_numbered', 'files_read', 'ls', 'grep', 'glob'];
  if (alwaysShowOutput.includes(action)) {
    return true;
  }
  
  // Actions with output_display: conditional
  if (action === 'exec') {
    // Check return_output parameter (default is true)
    return params?.return_output !== false;
  }
  
  // Default to showing output for unknown actions
  return true;
}

 
=== END FILE: /Users/stuart/repos/clada/proj/comp/listener/src/formatters.ts ===

=== START FILE: /Users/stuart/repos/clada/proj/comp/listener/src/listener.ts ===
import { watchFile, unwatchFile, Stats } from 'fs';
import { readFile, writeFile, access, constants } from 'fs/promises';
import { dirname, join } from 'path';
import clipboard from 'clipboardy';

import type { ListenerConfig, ListenerHandle, ListenerState } from './types.js';
import { ListenerError } from './errors.js';
import { Clada } from '../../orch/src/index.js';
import { formatSummary, formatFullOutput } from './formatters.js';
import { computeContentHash } from './utils.js';

// Module-level state for tracking active listeners
const activeListeners = new Map<string, ListenerHandle>();

// Strip prepended summary section if present
function stripSummarySection(content: string): string {
  const marker = '=== END ===';
  const i = content.lastIndexOf(marker);
  return i === -1 ? content : content.slice(i + marker.length).trimStart();
}


// Debounce utility
function debounce<T extends (...args: any[]) => any>(
  func: T,
  wait: number
): T & { cancel: () => void } {
  let timeout: NodeJS.Timeout | null = null;
  
  const debounced = (...args: Parameters<T>) => {
    if (timeout) clearTimeout(timeout);
    timeout = setTimeout(() => {
      func(...args);
    }, wait);
  };
  
  debounced.cancel = () => {
    if (timeout) clearTimeout(timeout);
  };
  
  return debounced as T & { cancel: () => void };
}

// Generate unique ID for listener instance
function generateId(): string {
  return `listener-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
}

// Format clipboard status line
function formatClipboardStatus(success: boolean, timestamp: Date): string {
  const time = timestamp.toLocaleTimeString();
  return success ?
    `üìã Copied to clipboard` :
    `‚ùå Clipboard copy failed`;
}

// Process file changes
async function processFileChange(filePath: string, state: ListenerState): Promise<void> {
  // Check not already processing
  if (state.isProcessing) return;
  
  try {
    state.isProcessing = true;
    
    // Read file
    const fullContent = await readFile(filePath, 'utf-8');
    if (fullContent.trim() == ""){
      return;
    }
    
    // Strip summary section for hashing
    const contentForHash = stripSummarySection(fullContent).trim();
    
    // // DIAGNOSTIC: Log stripping results
    // console.log('\n=== STRIP SUMMARY ===');
    // console.log('Original length:', fullContent.length);
    // console.log('Stripped length:', contentForHash.length);
    // console.log('Stripped content preview:', contentForHash.substring(0, 150).replace(/\n/g, '\\n'));
    // console.log('=== END STRIP ===\n');
    
    // Compute hash of content (excluding summary)
    const currentHash = computeContentHash(contentForHash);
    
    // // DIAGNOSTIC: Log hash comparison
    // console.log('Current hash:', currentHash);
    // console.log('Last hash:', state.lastExecutedHash);
    
    // Skip if unchanged
    if (currentHash === state.lastExecutedHash) {
      // console.log('Content unchanged, skipping execution');
      return;
    }
    
    // Execute via orchestrator with full file content
    const clada = new Clada({ gitCommit: false });
    const orchResult = await clada.execute(fullContent);
    
    // Debug logging
    if (state.debug) {
      console.log('\n=== DEBUG: Orchestrator Result ===');
      console.log('Executed actions:', orchResult.executedActions);
      console.log('Results:', orchResult.results?.length || 0);
      console.log('Parse errors:', orchResult.parseErrors?.length || 0);
      if (orchResult.parseErrors && orchResult.parseErrors.length > 0) {
        console.log('Raw parseErrors:', JSON.stringify(orchResult.parseErrors, null, 2));
      }
      console.log('=== END DEBUG ===\n');
    }
    
    // Format outputs
    const timestamp = new Date();
    const summary = formatSummary(orchResult, timestamp);
    const fullOutput = await formatFullOutput(orchResult);
    
    // Copy to clipboard
    let clipboardSuccess = false;
    try {
      await clipboard.write(fullOutput);
      clipboardSuccess = true;
    } catch (error) {
      console.error('listener: Clipboard write failed:', error);
    }
    
    // Format clipboard status
    const clipboardStatus = formatClipboardStatus(clipboardSuccess, timestamp);
    
    // Write output file (without clipboard status)
    await writeFile(state.outputPath, fullOutput);
    
    // Prepend to input file with clipboard status
    const prepend = clipboardStatus + '\n' + summary;
    const updatedContent = prepend + '\n' + fullContent;
    await writeFile(filePath, updatedContent);
    
    // Update state
    state.lastExecutedHash = currentHash;
    
  } catch (error) {
    console.error('listener: Error processing file change:', error);
  } finally {
    state.isProcessing = false;
  }
}

export async function startListener(config: ListenerConfig): Promise<ListenerHandle> {
  // Validate config
  if (!config.filePath) {
    throw new Error('listener: filePath is required');
  }
  if (!config.filePath.startsWith('/')) {
    throw new Error('listener: filePath must be absolute');
  }
  if (config.debounceMs !== undefined && config.debounceMs < 100) {
    throw new Error('listener: debounceMs must be at least 100');
  }
  
  // Check file exists
  try {
    await access(config.filePath, constants.F_OK);
  } catch (error) {
    throw new ListenerError('FILE_NOT_FOUND', config.filePath);
  }
  
  // Check not already watching
  if (activeListeners.has(config.filePath)) {
    throw new ListenerError('ALREADY_WATCHING', config.filePath);
  }
  
  // Initialize state
  const state: ListenerState = {
    lastExecutedHash: '',
    isProcessing: false,
    outputPath: join(dirname(config.filePath), config.outputFilename || '.clada-output-latest.txt'),
    debug: config.debug || false
  };
  
  // Set up debounced handler
  const debouncedProcess = debounce(
    () => {
      // console.log('Debounced process executing');
      processFileChange(config.filePath, state);
    },
    config.debounceMs || 500
  );
  
  // Start watching
  watchFile(config.filePath, { interval: 500 }, (curr: Stats, prev: Stats) => {
    if (curr.mtime !== prev.mtime) {
      // console.log('File change detected, triggering debounced process');
      debouncedProcess();
    }
  });
  
  // Process initial content
  debouncedProcess();
  
  // Create handle
  const handle: ListenerHandle = {
    id: generateId(),
    filePath: config.filePath,
    stop: async () => {
      unwatchFile(config.filePath);
      debouncedProcess.cancel();
      activeListeners.delete(config.filePath);
    }
  };
  
  // Track active listener
  activeListeners.set(config.filePath, handle);
  
  return handle;
}

export async function stopListener(handle: ListenerHandle): Promise<void> {
  await handle.stop();
}
=== END FILE: /Users/stuart/repos/clada/proj/comp/listener/src/listener.ts ===

=== START FILE: /Users/stuart/repos/clada/replacer/replacer_llm_instructions.md ===
coding style guide:  TDD.  self documenting code.  every api  function name should make it super obvious who is doing what and why

WOL = "words or less, please"

keep the docs as lean

refactor code to make it smaller whenever possible.  DRY.

IMPORTANT:  do not generate edit instructions unless specifically asked to.  not necessary when just discussing and brainstorming

- all code functions and classes or large (10 lines of code or more?) need code comments to cocnisely and lcearly describe what they're doing and why and how

IMPORTANT: 

whenever you generate new code, use the following format.  dont just generate a standalone artifact.  when generating one or multiple new files, use the OVERWRITE pattern shown below 

For each specific edit that needs to happen, list a brief explanation for the change, list file name, and then explicitly make it clear what the target text is that need to be changed, and then the replacement text is that will replace it. Each of those blocks of text or code need to be explicit verbatim character by character Perfect matches for the intended text.  be sure to put the filenames and expalanations on their own lines for easy human reading even in output format.  like paragraph breaks before and after so thye're on their own lines even when not in code blocks.  use this format below exactly. note that the OVERWRITE style block can be used to create new files and its parent dirs.

make the search find text or code blocks as small as possible to still be unique identifiers for what needs to be changed in the underlying files 

for the file path, use as much of the path that you know of.  should be as specific as you can accurately be.  

make sure that file paths include the current main project dir

<<<EXPLANATION>>>

this is why the change should happen

<<<FILE>>>

package/replacer_demo_src/main.py

<<<SEARCH>>>
def old_function():
   x = 1
   y = 2
   return x + y
<<<REPLACE>>>
def new_function():
   result = 3
   return result
<<<END>>>




<<<EXPLANATION>>>

this is why this change should happen

<<<FILE>>>
july/coding/bobstuff/react/config/settings.json
<<<OVERWRITE>>>
{
   "debug": true,
   "port": 8080
}
<<<END>>>

NOTE: if you want to remove a section of code, your replace block must contain a blank line and a space:


<<<EXPLANATION>>>

remove the search code

<<<FILE>>>

package/replacer_demo_src/main.py

<<<SEARCH>>>
def old_function():
   x = 1
   y = 2
   return x + y
<<<REPLACE>>>
 
<<<END>>>

see how the REPLACE block can never be totally empty. must contain blank line and whitespace (space(s)) too

IMPORTANT:  each edit item must list its associated FILE.  each SEARCH/REPLACE or OVERWRITE etc block must be immediately preceeded by the respective file 

$$$$$$$$$$$$$

Prioritize substance, clarity, and depth. Challenge all my proposals, designs, and conclusions as hypotheses to be tested. Sharpen follow-up questions for precision, surfacing hidden assumptions, trade offs, and failure modes early. Default to terse, logically structured, information-dense responses unless detailed exploration is required. Skip unnecessary praise unless grounded in evidence. Explicitly acknowledge uncertainty when applicable. Always propose at least one alternative framing. Accept critical debate as normal and preferred. Treat all factual claims as provisional unless cited or clearly justified. Cite when appropriate. Acknowledge when claims rely on inference or incomplete information. Favor accuracy over sounding certain.

check anything online when it feels relevant.  good to compare our thoughts/assumptions with what other people are actually doing and thinking

when asked to share your thoughts (like if user says "wdyt"), then walk it out and talk it out gradually, incrementally, slowly, and thoughtfully.  challenge me so we can succeed overall

dont fall into the trap of equating "implementation" with "low-level".  implementation decisions can be high-level when they affect the system's fundamental behavior

IMPORTANT EDIT INSTRUCTIONS NOTE:

- always use full absolute file paths for edit instructions

- to delete a file, share bash commands with the user in your response.  do not use edit instructions to delete a file


=== END FILE: /Users/stuart/repos/clada/replacer/replacer_llm_instructions.md ===

