=== START FILE: /Users/stuart/repos/clada/replacer/replacer_llm_instructions.md ===
coding style guide:  TDD.  self documenting code.  every api  function name should make it super obvious who is doing what and why

WOL = "words or less, please"

keep the docs as lean

refactor code to make it smaller whenever possible.  DRY.

IMPORTANT:  do not generate edit instructions unless specifically asked to.  not necessary when just discussing and brainstorming

- all code functions and classes or large (10 lines of code or more?) need code comments to cocnisely and lcearly describe what they're doing and why and how

IMPORTANT: 

whenever you generate new code, use the following format.  dont just generate a standalone artifact.  when generating one or multiple new files, use the OVERWRITE pattern shown below 

For each specific edit that needs to happen, list a brief explanation for the change, list file name, and then explicitly make it clear what the target text is that need to be changed, and then the replacement text is that will replace it. Each of those blocks of text or code need to be explicit verbatim character by character Perfect matches for the intended text.  be sure to put the filenames and expalanations on their own lines for easy human reading even in output format.  like paragraph breaks before and after so thye're on their own lines even when not in code blocks.  use this format below exactly. note that the OVERWRITE style block can be used to create new files and its parent dirs.

make the search find text or code blocks as small as possible to still be unique identifiers for what needs to be changed in the underlying files 

for the file path, use as much of the path that you know of.  should be as specific as you can accurately be.  

make sure that file paths include the current main project dir

<<<EXPLANATION>>>

this is why the change should happen

<<<FILE>>>

package/replacer_demo_src/main.py

<<<SEARCH>>>
def old_function():
   x = 1
   y = 2
   return x + y
<<<REPLACE>>>
def new_function():
   result = 3
   return result
<<<END>>>




<<<EXPLANATION>>>

this is why this change should happen

<<<FILE>>>
july/coding/bobstuff/react/config/settings.json
<<<OVERWRITE>>>
{
   "debug": true,
   "port": 8080
}
<<<END>>>

NOTE: if you want to remove a section of code, your replace block must contain a blank line and a space:


<<<EXPLANATION>>>

remove the search code

<<<FILE>>>

package/replacer_demo_src/main.py

<<<SEARCH>>>
def old_function():
   x = 1
   y = 2
   return x + y
<<<REPLACE>>>
 
<<<END>>>

see how the REPLACE block can never be totally empty. must contain blank line and whitespace (space(s)) too

IMPORTANT:  each edit item must list its associated FILE.  each SEARCH/REPLACE or OVERWRITE etc block must be immediately preceeded by the respective file 

$$$$$$$$$$$$$

Prioritize substance, clarity, and depth. Challenge all my proposals, designs, and conclusions as hypotheses to be tested. Sharpen follow-up questions for precision, surfacing hidden assumptions, trade offs, and failure modes early. Default to terse, logically structured, information-dense responses unless detailed exploration is required. Skip unnecessary praise unless grounded in evidence. Explicitly acknowledge uncertainty when applicable. Always propose at least one alternative framing. Accept critical debate as normal and preferred. Treat all factual claims as provisional unless cited or clearly justified. Cite when appropriate. Acknowledge when claims rely on inference or incomplete information. Favor accuracy over sounding certain.

check anything online when it feels relevant.  good to compare our thoughts/assumptions with what other people are actually doing and thinking

when asked to share your thoughts (like if user says "wdyt"), then walk it out and talk it out gradually, incrementally, slowly, and thoughtfully.  challenge me so we can succeed overall

dont fall into the trap of equating "implementation" with "low-level".  implementation decisions can be high-level when they affect the system's fundamental behavior

IMPORTANT EDIT INSTRUCTIONS NOTE:

- always use full absolute file paths for edit instructions

- to delete a file, share bash commands with the user in your response.  do not use edit instructions to delete a file


=== END FILE: /Users/stuart/repos/clada/replacer/replacer_llm_instructions.md ===

=== START FILE: /Users/stuart/repos/clada/xd5_ref.md ===
# XD5 LLM Quick Reference

## Core Principle
Documentation maintains dependency graphs for deterministic context assembly. Initial dependencies are hypotheses - implementation discovers reality. The STOP protocol ensures documentation evolves to match actual dependencies.

## File Structure
```
<repo>/
└── proj/
    ├── doc/
    │   ├── API.md        # ⚠️ CRITICAL: All dependencies + exports
    │   ├── ABSTRACT.md   # 60-word purpose + 300-word overview
    │   └── ARCH.md       # Technical decisions, constraints
    ├── test-data/        # Test cases as JSON/MD files
    │   ├── unit/         # Unit test data
    │   └── integration/  # Integration test data
    ├── test/             # Minimal harnesses loading test-data
    │   ├── unit/         # Unit test harnesses
    │   └── integration/  # Integration test harnesses
    ├── test-intn/        # Integration tests for dependencies
    ├── src/              # Implementation
    └── comp/             # Sub-components (recursive) - do not need 'proj' dirs
```

## API.md Template
```markdown
# Component: {name}

## Component Type
standard | types-only

## Dependencies
[Provisional - updated via STOP protocol when implementation reveals actual needs]

Mark internal component status: [PLANNED], [IN-PROGRESS], or [IMPLEMENTED]
External dependencies do not need status markers.

```yaml
dependencies:
  # Initial hypothesis based on design
  proj/comp/payment:                                       # [PLANNED]
    functions: [validateCard, processRefund] # may change 
    types: [PaymentResult, CardType]
    errors: [PaymentError]
  
  proj/comp/auth:                                          # [IMPLEMENTED]
    functions: [checkPermission, validateToken]
    types: [User, TokenPayload]
  
  proj/comp/logger:                                        # [IN-PROGRESS]
    functions: [logTransaction]  # Audit requirement
  
  proj/comp/payment-types: "*"  # Wildcard for types-only  # [IMPLEMENTED] 
  
  external/lodash:
    functions: [groupBy, mapValues]
  
  external/@stripe/stripe-js:
    types: [Stripe, PaymentIntent]
    functions: [loadStripe]
```

## Exports
[Structured YAML for dependency graph tooling, then prose descriptions]

```yaml
exports:
  functions: [functionName1, functionName2]
  types: [Type1, Type2, Type3]
  classes:
    ClassName:
      methods: [method1, method2]
  errors: [CustomError1, CustomError2]
```

### {functionName}
- **Signature**: `{functionName}(param: Type) -> ReturnType`
- **Purpose**: Single sentence.
- **Throws**: `{ErrorType}` when {condition}
- **Test-data**: `test-data/{path}/{functionName}.json` [PLANNED|IMPLEMENTED]



## Workflow

### Core Flow: Design → Test → Implement

1. **Write docs**: ABSTRACT.md → ARCH.md → API.md (provisional)
2. **Design tests**: E2E hypothesis → Decompose → Unit tests  
3. **Implement**: Discover real dependencies → Update docs → Complete code

### Test Authority & Evolution

**Tests Are Source of Truth (But Not Infallible)**
- Tests define what code SHOULD do
- During debug: ALWAYS fix code to match tests first
- Test errors discovered? Ask human: "I believe test X is incorrect because Y. Should I update it?"
- NEVER auto-modify tests while debugging
- Each test change needs explicit approval

### Detailed Flow

1. **E2E Test Hypothesis** - Write component test-data (expect evolution)
2. **Pseudocode** - Rough implementation to discover structure
3. **Extract Functions** - Identify & extract all pure functions
4. **Unit Tests** - Write test-data for each function
5. **Implement Functions** - Red/green/debug (fix code, not tests)
6. **Revise E2E Tests** - Align with discovered behavior (ask human)
7. **Wire Component** - Connect tested functions
8. **Debug E2E** - Fix code until green

**Debug Protocol**: Test fails? → Try fixing code → Still failing? → Consider test error → Request human approval for any test change

**If docs are wrong**: STOP → Update docs → Update tests → Continue



### Critical Implementation Rules

**Initial Docs Are Hypotheses**: 
- First API.md contains best guesses
- Dependencies WILL be wrong
- This is expected and healthy
- Discovery through implementation is the goal

**🛑 STOP Protocol**: When implementation reveals doc errors:
1. STOP immediately
2. Update API.md/ARCH.md
3. Continue with correct docs

**Test Immutability**: 
- Test harnesses = frozen after creation
- Test data = only change with human approval
- Fix code, not tests (unless explicitly approved)

**Dependency Updates**:
- Add to API.md as discovered
- Include transitive deps if needed for understanding
- External deps must be explicit

## Test Data Format
```json
{
  "cases": [
    {
      "name": "descriptive name",
      "input": [arg1, arg2],
      "expected": {result},
      "throws": "ErrorType"  // optional
    }
  ]
}
```

## Quick Checks

Before implementing:
- [ ] API.md declares all exports?
- [ ] Dependencies section updated?
- [ ] Test data files created?

During implementation:
- [ ] Tests fail first (red phase)?
- [ ] Docs match reality? (if not → STOP)
- [ ] All imports declared in API.md?

## Common Patterns

**Extract pure functions during pseudocode**:
```javascript
// Pseudocode reveals:
// extractedFn: validateInput(x) -> bool
// extractedFn: processData(data) -> result
```

**Types-only components**: No test/ or src/, only doc/

**Path conventions**: All relative to `<repo>/`
- Component: `proj/comp/{name}`
- Nested: `proj/comp/{parent}/comp/{child}`


# update 

- need to update this so that we save our pseudocde in some sort of documetnation, maybe temp documentation.  so if we implement the fucntiosn to unit test, we dont get confused later about how theyre supposed to be used.

- ideally, each extracted function unit-testable function would be in its own file.  for parallelism with the unit test files

- TESTING PATHS

dont save files directly to `/tmp/`.  save them to a dir in the tmp dir taht is named with the name of the test preceedd by 't_', eg `/tmp/t_move-nonexistent-file`

like: 


### 003-move-nonexistent-file

```sh sham
#!SHAM [@three-char-SHA-256: mnf]
action = "file_move"
old_path = "/tmp/t_move-nonexistent-file/ghost.txt"
new_path = "/tmp/t_move-nonexistent-file/nowhere.txt"
#!END_SHAM_mnf
```

```json
{
  "success": false,
  "error": "file_move: Source file not found '/tmp/t_move-nonexistent-file/ghost.txt' (ENOENT)"
}
```

=== END FILE: /Users/stuart/repos/clada/xd5_ref.md ===

=== START FILE: /Users/stuart/repos/clada/proj/comp/fs-ops/test-data/integration/file_read_numbered.cases.md ===
# file_read_numbered Integration Tests

## file_read_numbered

### 001-read-single-line

```sh sham
#!SHAM [@three-char-SHA-256: rs1]
action = "file_write"
path = "/tmp/t_read-single-line/numbered.txt"
content = <<'EOT_SHAM_rs1'
Line 1
Line 2
Line 3
Line 4
Line 5
EOT_SHAM_rs1
#!END_SHAM_rs1

#!SHAM [@three-char-SHA-256: rs2]
action = "file_read_numbered"
path = "/tmp/t_read-single-line/numbered.txt"
lines = "3"
#!END_SHAM_rs2
```

```json
{
  "success": true,
  "data": {
    "path": "/tmp/t_read-single-line/numbered.txt",
    "content": "     3: Line 3"
  }
}
```

### 002-read-line-range

```sh sham
#!SHAM [@three-char-SHA-256: rr1]
action = "file_write"
path = "/tmp/t_read-line-range/numbered.txt"
content = <<'EOT_SHAM_rr1'
First line
Second line
Third line
Fourth line
Fifth line
Sixth line
Seventh line
EOT_SHAM_rr1
#!END_SHAM_rr1

#!SHAM [@three-char-SHA-256: rr2]
action = "file_read_numbered"
path = "/tmp/t_read-line-range/numbered.txt"
lines = "3-5"
#!END_SHAM_rr2
```

```json
{
  "success": true,
  "data": {
    "path": "/tmp/t_read-line-range/numbered.txt",
    "content": "     3: Third line\n     4: Fourth line\n     5: Fifth line"
  }
}
```

### 003-read-with-custom-delimiter

```sh sham
#!SHAM [@three-char-SHA-256: cd1]
action = "file_write"
path = "/tmp/t_read-with-custom-delimiter/numbered.txt"
content = <<'EOT_SHAM_cd1'
import os
import sys

def main():
    print("Hello, World!")
    
if __name__ == "__main__":
    main()
EOT_SHAM_cd1
#!END_SHAM_cd1

#!SHAM [@three-char-SHA-256: cd2]
action = "file_read_numbered"
path = "/tmp/t_read-with-custom-delimiter/numbered.txt"
lines = "4-7"
delimiter = "    "
#!END_SHAM_cd2
```

```json
{
  "success": true,
  "data": {
    "path": "/tmp/t_read-with-custom-delimiter/numbered.txt",
    "content": "     4    def main():\n     5        print(\"Hello, World!\")\n     6        \n     7    if __name__ == \"__main__\":"
  }
}
```

### 004-read-with-empty-delimiter

```sh sham
#!SHAM [@three-char-SHA-256: ed1]
action = "file_write"
path = "/tmp/t_read-with-empty-delimiter/numbered.txt"
content = <<'EOT_SHAM_ed1'
apple
banana
cherry
date
EOT_SHAM_ed1
#!END_SHAM_ed1

#!SHAM [@three-char-SHA-256: ed2]
action = "file_read_numbered"
path = "/tmp/t_read-with-empty-delimiter/numbered.txt"
lines = "2-3"
delimiter = ""
#!END_SHAM_ed2
```

```json
{
  "success": true,
  "data": {
    "path": "/tmp/t_read-with-empty-delimiter/numbered.txt",
    "content": "     2banana\n     3cherry"
  }
}
```

### 005-read-out-of-range-lines

```sh sham
#!SHAM [@three-char-SHA-256: or1]
action = "file_write"
path = "/tmp/t_read-out-of-range-lines/numbered.txt"
content = <<'EOT_SHAM_or1'
Only
Three
Lines
EOT_SHAM_or1
#!END_SHAM_or1

#!SHAM [@three-char-SHA-256: or2]
action = "file_read_numbered"
path = "/tmp/t_read-out-of-range-lines/numbered.txt"
lines = "2-10"
#!END_SHAM_or2
```

```json
{
  "success": false,
  "error": "file_read_numbered: Requested lines 2-10 but file only has 3 lines",
  "data": {
    "path": "/tmp/t_read-out-of-range-lines/numbered.txt",
    "content": "     2: Three\n     3: Lines"
  }
}
```

### 006-read-single-line-file

```sh sham
#!SHAM [@three-char-SHA-256: sl1]
action = "file_write"
path = "/tmp/t_read-single-line-file/numbered.txt"
content = "Just one line"
#!END_SHAM_sl1

#!SHAM [@three-char-SHA-256: sl2]
action = "file_read_numbered"
path = "/tmp/t_read-single-line-file/numbered.txt"
lines = "1"
#!END_SHAM_sl2
```

```json
{
  "success": true,
  "data": {
    "path": "/tmp/t_read-single-line-file/numbered.txt",
    "content": "     1: Just one line"
  }
}
```

### 007-read-empty-file

```sh sham
#!SHAM [@three-char-SHA-256: ef1]
action = "file_write"
path = "/tmp/t_read-empty-file/numbered.txt"
content = ""
#!END_SHAM_ef1

#!SHAM [@three-char-SHA-256: ef2]
action = "file_read_numbered"
path = "/tmp/t_read-empty-file/numbered.txt"
lines = "1"
#!END_SHAM_ef2
```

```json
{
  "success": true,
  "data": {
    "path": "/tmp/t_read-empty-file/numbered.txt",
    "content": ""
  }
}
```

### 008-invalid-line-format

```sh sham
#!SHAM [@three-char-SHA-256: if1]
action = "file_write"
path = "/tmp/t_invalid-line-format/numbered.txt"
content = "Some content"
#!END_SHAM_if1

#!SHAM [@three-char-SHA-256: if2]
action = "file_read_numbered"
path = "/tmp/t_invalid-line-format/numbered.txt"
lines = "abc"
#!END_SHAM_if2
```

```json
{
  "success": false,
  "error": "file_read_numbered: Invalid line specification 'abc'"
}
```

### 009-invalid-line-range

```sh sham
#!SHAM [@three-char-SHA-256: ir1]
action = "file_write"
path = "/tmp/t_invalid-line-range/numbered.txt"
content = "Some content"
#!END_SHAM_ir1

#!SHAM [@three-char-SHA-256: ir2]
action = "file_read_numbered"
path = "/tmp/t_invalid-line-range/numbered.txt"
lines = "5-3"
#!END_SHAM_ir2
```

```json
{
  "success": false,
  "error": "file_read_numbered: Invalid line range '5-3' (start must be <= end)"
}
```

### 010-read-nonexistent-file

```sh sham
#!SHAM [@three-char-SHA-256: nf1]
action = "file_read_numbered"
path = "/tmp/t_read-nonexistent-file/does-not-exist.txt"
lines = "1-5"
#!END_SHAM_nf1
```

```json
{
  "success": false,
  "error": "ENOENT: no such file or directory, open '/tmp/t_read-nonexistent-file/does-not-exist.txt'"
}
```

### 011-read-completely-out-of-range

```sh sham
#!SHAM [@three-char-SHA-256: co1]
action = "file_write"
path = "/tmp/t_read-completely-out-of-range/numbered.txt"
content = <<'EOT_SHAM_co1'
Line 1
Line 2
EOT_SHAM_co1
#!END_SHAM_co1

#!SHAM [@three-char-SHA-256: co2]
action = "file_read_numbered"
path = "/tmp/t_read-completely-out-of-range/numbered.txt"
lines = "5-10"
#!END_SHAM_co2
```

```json
{
  "success": false,
  "error": "file_read_numbered: Requested lines 5-10 but file only has 2 lines",
  "data": {
    "path": "/tmp/t_read-completely-out-of-range/numbered.txt",
    "content": ""
  }
}
```

### 012-read-all-lines-missing-parameter

```sh sham
#!SHAM [@three-char-SHA-256: al1]
action = "file_write"
path = "/tmp/t_read-all-lines-missing-parameter/numbered.txt"
content = <<'EOT_SHAM_al1'
First line
Second line
Third line
Fourth line
Fifth line
EOT_SHAM_al1
#!END_SHAM_al1

#!SHAM [@three-char-SHA-256: al2]
action = "file_read_numbered"
path = "/tmp/t_read-all-lines-missing-parameter/numbered.txt"
#!END_SHAM_al2
```

```json
{
  "success": true,
  "data": {
    "path": "/tmp/t_read-all-lines-missing-parameter/numbered.txt",
    "content": "     1: First line\n     2: Second line\n     3: Third line\n     4: Fourth line\n     5: Fifth line"
  }
}
```

### 013-read-large-line-numbers

```sh sham
#!SHAM [@three-char-SHA-256: ll1]
action = "file_write"
path = "/tmp/t_read-large-line-numbers/numbered.txt"
content = <<'EOT_SHAM_ll1'
Line 1
Line 2
Line 3
Line 4
Line 5
Line 6
Line 7
Line 8
Line 9
Line 10
Line 11
Line 12
EOT_SHAM_ll1
#!END_SHAM_ll1

#!SHAM [@three-char-SHA-256: ll2]
action = "file_read_numbered"
path = "/tmp/t_read-large-line-numbers/numbered.txt"
lines = "9-11"
#!END_SHAM_ll2
```

```json
{
  "success": true,
  "data": {
    "path": "/tmp/t_read-large-line-numbers/numbered.txt",
    "content": "     9: Line 9\n    10: Line 10\n    11: Line 11"
  }
}
```
=== END FILE: /Users/stuart/repos/clada/proj/comp/fs-ops/test-data/integration/file_read_numbered.cases.md ===

=== START FILE: /Users/stuart/repos/clada/proj/comp/fs-ops/test/unit/extractNumberedLines.test.ts ===
import { describe, it, expect } from 'vitest';
import { extractNumberedLines } from '../../src/extractNumberedLines';
import { cases } from '../../test-data/unit/extractNumberedLines.cases';

describe('extractNumberedLines', () => {
  cases.forEach(({ name, input, expected, throws }) => {
    it(name, () => {
      if (throws) {
        expect(() => extractNumberedLines(...input)).toThrow(throws);
      } else {
        const result = extractNumberedLines(...input);
        expect(result).toEqual(expected);
      }
    });
  });
});
=== END FILE: /Users/stuart/repos/clada/proj/comp/fs-ops/test/unit/extractNumberedLines.test.ts ===

=== START FILE: /Users/stuart/repos/clada/proj/comp/fs-ops/test/unit/formatNodeError.test.ts ===
import { describe, it, expect } from 'vitest';
import { readFileSync } from 'fs';
import { join } from 'path';
import { formatNodeError } from '../../src/formatNodeError.js';

const testData = JSON.parse(
  readFileSync(join(__dirname, '../../test-data/unit/formatNodeError.cases.json'), 'utf8')
);

describe('formatNodeError', () => {
  testData.cases.forEach(({ name, input, expected }) => {
    it(name, () => {
      const result = formatNodeError(input[0], input[1], input[2], input[3]);
      expect(result).toEqual(expected);
    });
  });
});
=== END FILE: /Users/stuart/repos/clada/proj/comp/fs-ops/test/unit/formatNodeError.test.ts ===

=== START FILE: /Users/stuart/repos/clada/proj/comp/fs-ops/test/unit/replaceText.test.ts ===
import { describe, it, expect } from 'vitest';
import { replaceText } from '../../src/replaceText';
import { cases } from '../../test-data/unit/replaceText.cases';

describe('replaceText', () => {
  cases.forEach(({ name, input, expected, throws }) => {
    it(name, () => {
      if (throws) {
        expect(() => replaceText(...input)).toThrow(throws);
      } else {
        const result = replaceText(...input);
        expect(result).toEqual(expected);
      }
    });
  });
});

=== END FILE: /Users/stuart/repos/clada/proj/comp/fs-ops/test/unit/replaceText.test.ts ===

=== START FILE: /Users/stuart/repos/clada/proj/comp/fs-ops/test/integration/integration.test.ts ===
import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { readFileSync, rmSync, existsSync, writeFileSync, mkdirSync, readdirSync } from 'fs';
import { join } from 'path';
import { marked, Token } from 'marked';
import { parseShamResponse } from '../../../sham-action-parser/src/index.js';
import { executeFileOperation } from '../../src/index.js';

interface TestCase {
  name: string;
  shamBlock: string;
  expectedBlock: string;
}

interface TestGroup {
  name: string;
  tests: TestCase[];
}

// Read all test case files
const testDir = join(__dirname, '../../test-data/integration');
const testFiles = readdirSync(testDir)
  .filter(f => f.endsWith('.cases.md'))
  .sort();

// Extract test structure from all markdown files
const testGroups: TestGroup[] = [];

testFiles.forEach(filename => {
  const testPath = join(testDir, filename);
  const mdContent = readFileSync(testPath, 'utf8');
  
  let currentGroup: TestGroup | null = null;
  let currentTest: Partial<TestCase> | null = null;
  
  // Parse markdown to extract test cases with hierarchy
  const tokens: Token[] = marked.lexer(mdContent);
  
  tokens.forEach(token => {
    if (token.type === 'heading' && 'depth' in token) {
      if (token.depth === 2) {
        // New test group (e.g., "file_write")
        currentGroup = {
          name: (token as any).text,
          tests: []
        };
        testGroups.push(currentGroup);
      } else if (token.depth === 3 && currentGroup) {
        // New test case
        currentTest = {
          name: (token as any).text
        };
      }
    } else if (token.type === 'code' && currentTest && currentGroup) {
      const codeBlock = token as Token & {type: 'code', text: string};
      if (!currentTest.shamBlock) {
        currentTest.shamBlock = codeBlock.text;
      } else if (!currentTest.expectedBlock) {
        currentTest.expectedBlock = codeBlock.text;
        // Test case complete
        currentGroup.tests.push(currentTest as TestCase);
        currentTest = null;
      }
    }
  });
});

// Test cleanup paths
const testPaths = [
  '/tmp/test.txt',
  '/tmp/deeply',
  '/tmp/existing.txt',
  '/tmp/multiline.txt',
  '/tmp/to-delete.txt',
  '/tmp/does-not-exist.txt',
  '/tmp/source.txt',
  '/tmp/destination.txt',
  '/tmp/original.txt',
  '/tmp/new-dir',
  '/tmp/ghost.txt',
  '/tmp/nowhere.txt',
  '/tmp/source-exists.txt',
  '/tmp/dest-exists.txt',
  '/tmp/moveable.txt',
  '/tmp/replace-test.txt',
  '/tmp/multi-replace.txt',
  '/tmp/no-match.txt',
  '/tmp/does-not-exist-replace.txt',
  '/tmp/multiline-replace.txt',
  '/tmp/empty-search.txt',
  '/tmp/readable.txt',
  '/tmp/not-there.txt',
  '/tmp/multiple-occurrences.txt',
  '/tmp/replace-all.txt',
  '/tmp/count-mismatch.txt',
  '/tmp/special-chars.txt',
  '/tmp/numbered.txt'
];

describe('fs-ops integration tests', () => {
  let createdPaths: Set<string>;

  beforeEach(() => {
    createdPaths = new Set<string>(); // Fresh set per test

    // Clean up any existing test files
    for (const path of testPaths) {
      try {
        if (existsSync(path)) {
          rmSync(path, { recursive: true, force: true });
        }
      } catch (err) {
        // Silently continue
      }
    }
  });

  afterEach(() => {
    for (const path of createdPaths) {
      rmSync(path, { recursive: true, force: true });
    }
    // Clean up after tests
    for (const path of testPaths) {
      try {
        if (existsSync(path)) {
          rmSync(path, { recursive: true, force: true });
        }
      } catch (err) {
        // Silently continue
      }
    }
  });


  // Helper function to create test files and track paths
  const createTestFile = (testName: string, filename: string, content: string): void => {
    const testDir = `/tmp/t_${testName}`;
    mkdirSync(testDir, { recursive: true });
    writeFileSync(join(testDir, filename), content);
    createdPaths.add(testDir);
  };


  testGroups.forEach(group => {
    describe(group.name, () => {
      group.tests.forEach(test => {
        it(test.name, async () => {
          const expectedOutput = JSON.parse(test.expectedBlock);
          
          // Extract test name without number prefix
          const tn = test.name.replace(/^\d{3}-/, '');
          



          // Set up test preconditions based on group and test name
          if (group.name === 'file_delete' && tn === 'delete-existing-file') {
            createTestFile('delete-existing-file', 'to-delete.txt', 'This file will be deleted');
          } else if (group.name === 'file_move' && tn === 'move-file-simple') {
            createTestFile('move-file-simple', 'source.txt', 'Content to move');
          } else if (group.name === 'file_move' && tn === 'move-file-to-new-directory') {
            createTestFile('move-file-to-new-directory', 'original.txt', 'Moving to new directory');
          } else if (group.name === 'file_move' && tn === 'move-to-existing-file') {
            createTestFile('move-to-existing-file', 'source-exists.txt', 'Source content');
            createTestFile('move-to-existing-file', 'dest-exists.txt', 'Will be overwritten');
          } else if (group.name === 'file_replace_text' && tn === 'simple-text-replacement') {
            createTestFile('simple-text-replacement', 'replace-test.txt', 'Hello World');
          } else if (group.name === 'file_replace_text' && tn === 'replace-with-count-limit') {
            createTestFile('replace-with-count-limit', 'multi-replace.txt', 'foo bar foo baz foo qux foo');
          } else if (group.name === 'file_replace_text' && tn === 'replace-text-not-found') {
            createTestFile('replace-text-not-found', 'no-match.txt', 'This file has no matches');
          } else if (group.name === 'file_replace_text' && tn === 'multiline-replacement') {
            createTestFile('multiline-replacement', 'multiline-replace.txt', `export function oldName() {
  console.log('oldName');
  return oldName;
}

function oldName() {
  return oldName;
}

const x = oldName();`);
          } else if (group.name === 'file_replace_text' && tn === 'empty-old-text-error') {
            createTestFile('empty-old-text-error', 'empty-search.txt', 'Some content here');
          } else if (group.name === 'file_replace_text' && tn === 'file-replace-text-multiple-occurrences') {
            createTestFile('file-replace-text-multiple-occurrences', 'multiple-occurrences.txt', 'duplicate text with duplicate word and duplicate again');
          } else if (group.name === 'file_replace_text' && tn === 'file-replace-all-text-no-count') {
            createTestFile('file-replace-all-text-no-count', 'replace-all.txt', 'foo bar foo baz foo');
          } else if (group.name === 'file_replace_text' && tn === 'file-replace-all-text-count-mismatch') {
            createTestFile('file-replace-all-text-count-mismatch', 'count-mismatch.txt', 'test this test case');
          } else if (group.name === 'file_read' && tn === 'read-existing-file') {
            createTestFile('read-existing-file', 'readable.txt', 'This is readable content');
          }










          // Parse SHAM to get actions
          let parseResult;
          try {
            parseResult = await parseShamResponse(test.shamBlock);
            // Force a minimal action to test downstream code
            if (parseResult.actions.length === 0 && test.shamBlock.includes('action =')) {
              console.log('WARNING: Parser returned no actions, check parser implementation');
            }
          } catch (error) {
            console.log('Parse error:', error);
            throw error;
          }
          
          // Should have at least one action
          expect(parseResult.actions.length).toBeGreaterThan(0);
          expect(parseResult.errors).toHaveLength(0);
          
          // Execute all actions in sequence, capturing the last result
          let result;
          for (const action of parseResult.actions) {
            result = await executeFileOperation(action);
          }
          
          // Compare result
          expect(result).toEqual(expectedOutput);
        }, 30000);
      });
    });
  });
});
=== END FILE: /Users/stuart/repos/clada/proj/comp/fs-ops/test/integration/integration.test.ts ===

=== START FILE: /Users/stuart/repos/clada/proj/comp/fs-ops/src/extractNumberedLines.ts ===
/**
 * Extract and number specific lines from content
 * @param content - Full file content
 * @param lineSpec - Line specification ("4" for single line, "23-43" for range)
 * @param delimiter - Delimiter between line number and content
 * @returns Object with numbered lines and total line count
 * @throws Error for invalid line specifications
 */
export function extractNumberedLines(
  content: string,
  lineSpec: string | undefined,
  delimiter: string = ": "
): { result: string; lineCount: number; outOfRange?: { requested: string; actual: number } } {
  // Handle empty content
  if (content === '') {
    return { result: '', lineCount: 0 };
  }

  // Split content into lines
  const lines = content.split('\n');
  const totalLines = lines.length;

  // Parse line specification
  let startLine: number;
  let endLine: number;
  let requestedSpec: string;

  // If no lineSpec provided, read all lines
  if (!lineSpec) {
    startLine = 1;
    endLine = totalLines;
    requestedSpec = `1-${totalLines}`;
  } else {
    requestedSpec = lineSpec;

    if (lineSpec.includes('-')) {
      // Range format: "23-43"
      const parts = lineSpec.split('-');
      if (parts.length !== 2) {
        throw new Error(`Invalid line specification '${lineSpec}'`);
      }

      startLine = parseInt(parts[0], 10);
      endLine = parseInt(parts[1], 10);

      if (isNaN(startLine) || isNaN(endLine)) {
        throw new Error(`Invalid line specification '${lineSpec}'`);
      }

      if (startLine < 1 || endLine < 1) {
        throw new Error(`Invalid line specification '${lineSpec}' (line numbers must be positive)`);
      }

      if (startLine > endLine) {
        throw new Error(`Invalid line range '${lineSpec}' (start must be <= end)`);
      }
    } else {
      // Single line format: "4"
      startLine = parseInt(lineSpec, 10);
      if (isNaN(startLine) || startLine < 1) {
        throw new Error(`Invalid line specification '${lineSpec}'`);
      }
      endLine = startLine;
    }
  }

  // Check if request is out of range
  const originalStartLine = startLine;
  const originalEndLine = endLine;
  const isOutOfRange = startLine > totalLines || endLine > totalLines;

  // If start line is beyond file, return empty
  if (startLine > totalLines) {
    const result = {
      result: '',
      lineCount: totalLines
    };
    
    if (isOutOfRange) {
      result.outOfRange = {
        requested: requestedSpec,
        actual: totalLines
      };
    }
    
    return result;
  }

  // Clamp end line to available lines
  endLine = Math.min(endLine, totalLines);

  // Extract lines and format with numbers
  const numberedLines: string[] = [];
  const maxLineNum = Math.min(originalEndLine, totalLines);
  const numWidth = maxLineNum.toString().length;

  for (let i = startLine; i <= endLine && i <= totalLines; i++) {
    const lineNum = i.toString().padStart(numWidth + 5, ' ');
    numberedLines.push(`${lineNum}${delimiter}${lines[i - 1]}`);
  }

  const result = {
    result: numberedLines.join('\n'),
    lineCount: totalLines
  };

  if (isOutOfRange) {
    result.outOfRange = {
      requested: requestedSpec,
      actual: totalLines
    };
  }

  return result;
}
=== END FILE: /Users/stuart/repos/clada/proj/comp/fs-ops/src/extractNumberedLines.ts ===

=== START FILE: /Users/stuart/repos/clada/proj/comp/fs-ops/src/fileSystemUtils.ts ===
import { stat } from 'fs/promises';

/**
 * Check if a file or directory exists
 * @param path - File or directory path to check
 * @returns true if exists, false otherwise
 */
export async function fileExists(path: string): Promise<boolean> {
  try {
    await stat(path);
    return true;
  } catch {
    return false;
  }
}
=== END FILE: /Users/stuart/repos/clada/proj/comp/fs-ops/src/fileSystemUtils.ts ===

=== START FILE: /Users/stuart/repos/clada/proj/comp/fs-ops/src/formatNodeError.ts ===
/**
 * Format Node.js filesystem errors into consistent error messages
 * @param error - The error object from Node.js
 * @param path - The file path involved in the operation
 * @param operation - The operation that was attempted
 * @returns Formatted error message string
 */
export function formatNodeError(error: any, path: string, operation: string, dest?: string): string {
  // Node.js errors have a code property
  if (error.code) {
    switch (error.code) {
      case 'ENOENT':
        if (operation === 'rename' && dest) {
          return `ENOENT: no such file or directory, rename '${path}' -> '${dest}'`;
        }
        return `ENOENT: no such file or directory, ${operation} '${path}'`;
      case 'EEXIST':
        return `EEXIST: file already exists, ${operation} '${path}'`;
      case 'EACCES':
        if (operation === 'rename' && dest) {
          return `EACCES: permission denied, rename '${path}' -> '${dest}'`;
        }
        return `EACCES: permission denied, ${operation} '${path}'`;
      case 'EISDIR':
        return `EISDIR: illegal operation on a directory, ${operation} '${path}'`;
      case 'ENOTDIR':
        return `ENOTDIR: not a directory, ${operation} '${path}'`;
      case 'ENOTEMPTY':
        return `ENOTEMPTY: directory not empty, ${operation} '${path}'`;
      default:
        return `${error.code}: ${error.message}`;
    }
  }
  
  // Fallback for non-Node errors
  return error.message || `Unknown error during ${operation} on '${path}'`;
}
=== END FILE: /Users/stuart/repos/clada/proj/comp/fs-ops/src/formatNodeError.ts ===

=== START FILE: /Users/stuart/repos/clada/proj/comp/fs-ops/src/index.ts ===
/**
 * fs-ops - File system operations executor for clada
 * 
 * Handles all file and directory operations from parsed SHAM actions
 */

import type { CladaAction } from '../../sham-action-parser/src/index.js';
import { writeFile, mkdir, unlink, rename, readFile } from 'fs/promises';
import { dirname } from 'path';
import { formatNodeError } from './formatNodeError.js';
import { fileExists } from './fileSystemUtils.js';
import { replaceText } from './replaceText.js';
import { extractNumberedLines } from './extractNumberedLines.js';

export interface FileOpResult {
  success: boolean;
  data?: any;
  error?: string;
}

export class FileOpError extends Error {
  constructor(
    message: string,
    public code: string,
    public path?: string,
    public operation?: string
  ) {
    super(message);
    this.name = 'FileOpError';
  }
}

/**
 * Execute a file system operation from a parsed SHAM action
 * Never throws - all errors returned in result
 */
export async function executeFileOperation(action: CladaAction): Promise<FileOpResult> {
  try {
    const handler = actionHandlers[action.action];
    
 
    
    if (!handler) {
      return {
        success: false,
        error: `Unknown action: ${action.action}`
      };
    }
    
    const result = await handler(action);
    return result;
    
  } catch (error: any) {
    // This should never happen - handlers should catch their own errors
    return {
      success: false,
      error: `Unexpected error in executeFileOperation: ${error.message}`
    };
  }
}

/**
 * Handle file_move action - moves/renames a file
 * Creates parent directories for destination if needed
 * Overwrites destination if it exists
 */
async function handleFileMove(action: CladaAction): Promise<FileOpResult> {
  const { old_path, new_path } = action.parameters;
  
  try {
    // Pre-flight check for better error messages
    const sourceExists = await fileExists(old_path);
    if (!sourceExists) {
      return {
        success: false,
        error: `file_move: Source file not found '${old_path}' (ENOENT)`
      };
    }
    
    // Check if destination exists (for overwrote flag)
    const destExists = await fileExists(new_path);
    
    // Create parent directories for destination
    const parentDir = dirname(new_path);
    await mkdir(parentDir, { recursive: true });
    
    // Move the file
    await rename(old_path, new_path);
    
    const result: FileOpResult = {
      success: true,
      data: {
        old_path,
        new_path
      }
    };
    
    if (destExists) {
      result.data.overwrote = true;
    }
    
    return result;
    
  } catch (error: any) {
    return {
      success: false,
      error: formatNodeError(error, old_path, 'rename', new_path)
    };
  }
}

/**
 * Handle file_delete action - removes a file
 */
async function handleFileDelete(action: CladaAction): Promise<FileOpResult> {
  const { path } = action.parameters;
  
  try {
    await unlink(path);
    
    return {
      success: true,
      data: {
        path
      }
    };
    
  } catch (error: any) {
    return {
      success: false,
      error: formatNodeError(error, path, 'unlink')
    };
  }
}

/**
 * Handle file_write action - writes/creates/overwrites a file with content
 * Automatically creates parent directories if needed
 */
async function handleFileWrite(action: CladaAction): Promise<FileOpResult> {
  const { path, content } = action.parameters;
  
  try {
    // Create parent directories if needed
    const parentDir = dirname(path);
    await mkdir(parentDir, { recursive: true });
    
    // Write file
    await writeFile(path, content, 'utf8');
    const bytesWritten = Buffer.byteLength(content, 'utf8');
    
    return {
      success: true,
      data: {
        path,
        bytesWritten
      }
    };
    
  } catch (error: any) {
    return {
      success: false,
      error: formatNodeError(error, path, 'open')
    };
  }
}

/**
 * Handle file_read action - reads file content
 */
async function handleFileRead(action: CladaAction): Promise<FileOpResult> {
  const { path } = action.parameters;
  
  try {
    const content = await readFile(path, 'utf8');
    
    return {
      success: true,
      data: {
        path,
        content
      }
    };
    
  } catch (error: any) {
    return {
      success: false,
      error: formatNodeError(error, path, 'open')
    };
  }
}

/**
 * Handle file_read_numbered action - reads file content with line numbers
 * Returns specified lines with line numbers prepended
 * If lines parameter is missing, reads all lines
 * If some lines are out of range, returns available content with error
 */
async function handleFileReadNumbered(action: CladaAction): Promise<FileOpResult> {
  const { path, lines, delimiter = ": " } = action.parameters;
  
  try {
    const content = await readFile(path, 'utf8');
    
    // Extract and number the requested lines
    const { result, outOfRange } = extractNumberedLines(content, lines, delimiter);
    
    // If out of range, return error with partial content
    if (outOfRange) {
      return {
        success: false,
        error: `file_read_numbered: Requested lines ${outOfRange.requested} but file only has ${outOfRange.actual} lines`,
        data: {
          path,
          content: result
        }
      };
    }
    
    return {
      success: true,
      data: {
        path,
        content: result
      }
    };
    
  } catch (error: any) {
    // Check if it's our custom validation error
    if (error.message && error.message.startsWith('Invalid line')) {
      return {
        success: false,
        error: `file_read_numbered: ${error.message}`
      };
    }
    
    return {
      success: false,
      error: formatNodeError(error, path, 'open')
    };
  }
}

/**
 * Handle files_read action - reads multiple files and concatenates with delimiters
 * Parses multi-line paths parameter, one absolute path per line
 * Returns concatenated content with === /path/to/file === delimiters
 */
async function handleFilesRead(action: CladaAction): Promise<FileOpResult> {
  const { paths } = action.parameters;
  
  // Parse the multi-line paths string
  const pathList = paths
    .split('\n')
    .map(line => line.trim())
    .filter(line => line.length > 0);  // Remove empty lines
  
  if (pathList.length === 0) {
    return {
      success: false,
      error: 'files_read: No paths provided'
    };
  }
  
  // Read all files, collecting content and errors
  const results: Array<{ path: string; content?: string; error?: string }> = [];
  
  for (const filePath of pathList) {
    try {
      const content = await readFile(filePath, 'utf8');
      results.push({ path: filePath, content });
    } catch (error: any) {
      // Collect error for this file
      const errorMsg = formatNodeError(error, filePath, 'open');
      results.push({ path: filePath, error: errorMsg });
    }
  }
  
  // Check if any files failed to read
  const failedFiles = results.filter(r => r.error);
  if (failedFiles.length > 0) {
    // Return error listing all failed files
    const errorDetails = failedFiles
      .map(f => `  ${f.path}: ${f.error}`)
      .join('\n');
    return {
      success: false,
      error: `files_read: Failed to read ${failedFiles.length} file(s):\n${errorDetails}`
    };
  }
  
  // All files read successfully - concatenate with delimiters
  const concatenated = results
    .map(r => {
      const header = `=== ${r.path} ===`;
      return `${header}\n${r.content}`;
    })
    .join('\n\n');
  
  return {
    success: true,
    data: {
      paths: pathList,
      content: concatenated
    }
  };
}

/**
 * Handle file_replace_text action - replaces EXACTLY ONE occurrence
 * Fails if old_text appears 0 or 2+ times
 */
async function handleFileReplaceText(action: CladaAction): Promise<FileOpResult> {
  const { path, old_text, new_text } = action.parameters;
  
  // Validate old_text is not empty
  if (!old_text || old_text.length === 0) {
    return {
      success: false,
      error: 'file_replace_text: old_text cannot be empty'
    };
  }
  
  try {
    // Read existing file content
    const content = await readFile(path, 'utf8');
    
    // Count occurrences first
    let count = 0;
    let searchIndex = 0;
    while (true) {
      const index = content.indexOf(old_text, searchIndex);
      if (index === -1) break;
      count++;
      searchIndex = index + 1;
    }
    
    // Validate exactly one occurrence
    if (count === 0) {
      return {
        success: false,
        error: `file_replace_text: old_text not found in file`
      };
    }
    if (count > 1) {
      return {
        success: false,
        error: `file_replace_text: old_text appears ${count} times, must appear exactly once`
      };
    }
    
    // Replace the single occurrence
    const { result, replacements } = replaceText(content, old_text, new_text, 1);
    
    // Write updated content back
    await writeFile(path, result, 'utf8');
    
    return {
      success: true,
      data: {
        path,
        replacements
      }
    };
    
  } catch (error: any) {
    // Special case for empty old_text validation error
    if (error.message === 'old_text cannot be empty') {
      return {
        success: false,
        error: 'file_replace_text: old_text cannot be empty'
      };
    }
    
    return {
      success: false,
      error: formatNodeError(error, path, 'open')
    };
  }
}

/**
 * Handle file_replace_all_text action - replaces all occurrences
 * If count provided, validates exact match
 */
async function handleFileReplaceAllText(action: CladaAction): Promise<FileOpResult> {
  const { path, old_text, new_text, count } = action.parameters;
  
  // Validate old_text is not empty
  if (!old_text || old_text.length === 0) {
    return {
      success: false,
      error: 'file_replace_all_text: old_text cannot be empty'
    };
  }
  
  try {
    // Read existing file content
    const content = await readFile(path, 'utf8');
    
    // If count specified, validate it matches actual occurrences
    if (count !== undefined) {
      // Count actual occurrences
      let actualCount = 0;
      let searchIndex = 0;
      while (true) {
        const index = content.indexOf(old_text, searchIndex);
        if (index === -1) break;
        actualCount++;
        searchIndex = index + 1;
      }
      
      if (actualCount !== count) {
        return {
          success: false,
          error: `file_replace_all_text: expected ${count} occurrences but found ${actualCount}`
        };
      }
    }
    
    // Replace all occurrences
    const { result, replacements } = replaceText(content, old_text, new_text);
    
    // Write updated content back
    await writeFile(path, result, 'utf8');
    
    return {
      success: true,
      data: {
        path,
        replacements
      }
    };
    
  } catch (error: any) {
    // Special case for empty old_text validation error
    if (error.message === 'old_text cannot be empty') {
      return {
        success: false,
        error: 'file_replace_all_text: old_text cannot be empty'
      };
    }
    
    return {
      success: false,
      error: formatNodeError(error, path, 'open')
    };
  }
}

// Internal function stubs for each operation

async function createFile(path: string, content: string): Promise<void> {
  throw new Error('Not implemented');
}

 

async function replaceTextInFile(path: string, oldText: string, newText: string, count?: number): Promise<number> {
  throw new Error('Not implemented');
}

async function deleteFile(path: string): Promise<void> {
  throw new Error('Not implemented');
}

async function moveFile(oldPath: string, newPath: string): Promise<void> {
  throw new Error('Not implemented');
}

async function readFileContent(path: string): Promise<string> {
  throw new Error('Not implemented');
}

async function createDirectory(path: string): Promise<void> {
  throw new Error('Not implemented');
}

async function deleteDirectory(path: string): Promise<void> {
  throw new Error('Not implemented');
}

interface DirEntry {
  name: string;
  type: 'file' | 'directory';
  size: number;
  modified: Date;
}

async function listDirectory(path: string): Promise<DirEntry[]> {
  throw new Error('Not implemented');
}

interface GrepResult {
  file: string;
  line_number: number;
  line: string;
}

async function searchFiles(pattern: string, path: string, include?: string): Promise<GrepResult[]> {
  throw new Error('Not implemented');
}

async function globFiles(pattern: string, basePath: string): Promise<string[]> {
  throw new Error('Not implemented');
}

// Action handler mapping
const actionHandlers: Record<string, (action: CladaAction) => Promise<FileOpResult>> = {
  'file_write': handleFileWrite,
  'file_replace_text': handleFileReplaceText,
  'file_replace_all_text': handleFileReplaceAllText,
  'file_delete': handleFileDelete,
  'file_move': handleFileMove,
  'file_read': handleFileRead,
  'files_read': handleFilesRead,
  'file_read_numbered': handleFileReadNumbered,
  'dir_create': async (action) => {
    return { success: false, error: 'Not implemented' };
  },
  'dir_delete': async (action) => {
    return { success: false, error: 'Not implemented' };
  },
  'ls': async (action) => {
    return { success: false, error: 'Action not implemented: ls' };
  },
  'grep': async (action) => {
    return { success: false, error: 'Not implemented' };
  },
  'glob': async (action) => {
    return { success: false, error: 'Not implemented' };
  }
};
=== END FILE: /Users/stuart/repos/clada/proj/comp/fs-ops/src/index.ts ===

=== START FILE: /Users/stuart/repos/clada/proj/comp/fs-ops/src/replaceText.ts ===
/**
 * Replace occurrences of text in content with optional count limit
 * @param content - Original content
 * @param oldText - Text to find and replace
 * @param newText - Replacement text
 * @param count - Maximum replacements (default: replace all)
 * @returns Object with result string and number of replacements made
 */
export function replaceText(
  content: string, 
  oldText: string, 
  newText: string, 
  count?: number
): { result: string; replacements: number } {
  if (oldText === '') {
    throw new Error('old_text cannot be empty');
  }

  let result = content;
  let replacements = 0;
  let startIndex = 0;

  while (true) {
    const index = result.indexOf(oldText, startIndex);
    if (index === -1) break;
    
    if (count !== undefined && replacements >= count) break;
    
    result = result.slice(0, index) + newText + result.slice(index + oldText.length);
    startIndex = index + newText.length;
    replacements++;
  }

  return { result, replacements };
}
=== END FILE: /Users/stuart/repos/clada/proj/comp/fs-ops/src/replaceText.ts ===

=== START FILE: /Users/stuart/repos/clada/proj/comp/fs-ops/doc/ABSTRACT.md ===
# File System Operations

Executes file and directory operations from parsed SHAM actions, providing consistent error handling and operation results for LLM feedback.

## Overview

The fs-ops component is the primary executor for file system operations in clada. It receives parsed CladaAction objects from the sham-action-parser and performs the requested file system operations, returning standardized results that include success status, operation-specific data, and detailed error information when operations fail.

The component handles all file-related SHAM actions including file creation, editing, deletion, and reading, as well as directory operations and search functionality. It automatically handles common scenarios like creating parent directories for new files and provides detailed error messages that help the LLM understand why operations failed.

Each operation is designed to be atomic and independent, with no shared state between operations. This ensures predictable behavior and makes it easy for the LLM to reason about the effects of each action.
=== END FILE: /Users/stuart/repos/clada/proj/comp/fs-ops/doc/ABSTRACT.md ===

=== START FILE: /Users/stuart/repos/clada/proj/comp/fs-ops/doc/API.md ===
# Component: fs-ops

## Component Type
standard

## Status
[IMPLEMENTED] - All file operations (write, read, delete, move, replace_text, replace_all_text, files_read)
[NOT IMPLEMENTED] - Directory operations (dir_create, dir_delete, ls), search operations (grep, glob)

## Documentation Debt
- [ ] Integration test format is preliminary [IMPLEMENTED]
- [ ] Error handling strategy needs refinement
- [ ] Consider batching operations for efficiency

## Dependencies

[Updated via STOP protocol - initial hypothesis proved mostly correct]

```yaml
dependencies:
  node:fs/promises:
    functions: [writeFile, unlink, mkdir, rename, stat, readFile]
    
  node:path:
    functions: [dirname]
    # Note: removed unused - resolve, join (not yet needed)
    
  # Removed node:util - not used
  # Removed node:child_process - grep not yet implemented
```

## Exports

```yaml
exports:
  functions: [executeFileOperation]
  types: [FileOpResult]
  classes:
    FileOpError:
      extends: Error
```

### executeFileOperation
- **Signature**: `executeFileOperation(action: CladaAction) -> Promise<FileOpResult>`
- **Purpose**: Execute file system operations from parsed SHAM actions
- **Throws**: Never - all errors captured in FileOpResult
- **Test-data**: `test-data/integration/*.cases.md` [IMPLEMENTED]

### FileOpResult (type)
```typescript
interface FileOpResult {
  success: boolean
  data?: any           // Operation-specific return data
  error?: string       // Error message if failed
}
```

### FileOpError (type)
```typescript
interface FileOpError extends Error {
  code: string         // e.g., 'ENOENT', 'EACCES'
  path?: string        // File path involved
  operation: string    // Which operation failed
}
```

## Internal Functions

### createFile
- **Signature**: `createFile(path: string, content: string) -> Promise<void>`
- **Purpose**: Create new file with content, creating parent directories as needed

### writeFile  
- **Signature**: `writeFile(path: string, content: string) -> Promise<void>`
- **Purpose**: Overwrite existing file content

### replaceText
- **Signature**: `replaceText(content: string, oldText: string, newText: string, count?: number) -> {result: string, replacements: number}`
- **Purpose**: Pure function to replace text occurrences in string content
- **Throws**: Error when oldText is empty string
- **Behavior**: Replaces up to `count` occurrences (all if count undefined)

### deleteFile
- **Signature**: `deleteFile(path: string) -> Promise<void>`
- **Purpose**: Remove file

### moveFile
- **Signature**: `moveFile(oldPath: string, newPath: string) -> Promise<void>`
- **Purpose**: Move or rename file

### readFileContent
- **Signature**: `readFileContent(path: string) -> Promise<string>`
- **Purpose**: Read file content as UTF-8 string

### createDirectory
- **Signature**: `createDirectory(path: string) -> Promise<void>`
- **Purpose**: Create directory, including parent directories

### deleteDirectory
- **Signature**: `deleteDirectory(path: string) -> Promise<void>`
- **Purpose**: Remove directory (must be empty)

### listDirectory
- **Signature**: `listDirectory(path: string) -> Promise<DirEntry[]>`
- **Purpose**: List directory contents with metadata

### searchFiles
- **Signature**: `searchFiles(pattern: string, path: string, include?: string) -> Promise<GrepResult[]>`
- **Purpose**: Search for pattern in files (grep-like)

### globFiles
- **Signature**: `globFiles(pattern: string, basePath: string) -> Promise<string[]>`
- **Purpose**: Find files matching glob pattern

### extractNumberedLines
- **Signature**: `extractNumberedLines(content: string, lineSpec: string, delimiter: string) -> { result: string, lineCount: number }`
- **Purpose**: Pure function to extract and number specific lines from content
- **Parameters**:
  - `content`: Full file content
  - `lineSpec`: Line specification ("4" for single line, "23-43" for range)
  - `delimiter`: Delimiter between line number and content
- **Returns**: Object with numbered lines and total line count
- **Throws**: Error for invalid line specifications

### handleFileReadNumbered
- **Signature**: `handleFileReadNumbered(action: CladaAction) -> Promise<FileOpResult>`
- **Purpose**: Read file content with line numbers for specified line range
- **Parameters**: 
  - `path`: File path to read
  - `lines`: Line range string ("23-43") or single line ("4")
  - `delimiter`: Optional delimiter between line number and content (default: ": ")
- **Returns**: FileOpResult with numbered content
- **Test-data**: `test-data/integration/file_read_numbered.cases.md` [IMPLEMENTED]

## Action Mapping

```typescript
const actionHandlers = {
  // Implemented
  'file_write': handleFileWrite,
  'file_replace_text': handleFileReplaceText,
  'file_replace_all_text': handleFileReplaceAllText,
  'file_delete': handleFileDelete,
  'file_move': handleFileMove,
  'file_read': handleFileRead,
  'files_read': handleFilesRead,
  'file_read_numbered': handleFileReadNumbered,
  
  // Not implemented
  'dir_create': async (action) => ({ success: false, error: 'Not implemented' }),
  'dir_delete': async (action) => ({ success: false, error: 'Not implemented' }),
  'ls': async (action) => ({ success: false, error: 'Action not implemented: ls' }),
  'grep': async (action) => ({ success: false, error: 'Not implemented' }),
  'glob': async (action) => ({ success: false, error: 'Not implemented' })
}
```
=== END FILE: /Users/stuart/repos/clada/proj/comp/fs-ops/doc/API.md ===

=== START FILE: /Users/stuart/repos/clada/proj/comp/fs-ops/doc/ARCH.md ===
# fs-ops Architecture

## Design Philosophy

**Defensive Operations with Clear Errors**: Every operation should handle common failure cases gracefully and return descriptive errors that help the LLM understand what went wrong.

## Key Design Decisions

### Parent Directory Creation
- `file_write` automatically creates parent directories.  creates parent directory if it doesn't exist

### Text Replacement Strategy  
- Use exact string matching for both replace actions
- `file_replace_text`: Must find EXACTLY ONE occurrence (fails if 0 or 2+)
- `file_replace_all_text`: Replaces all occurrences, validates count if provided
- Empty old_text validation: Both actions reject empty search strings
- Return actual number of replacements made
- No regex support (keep it simple, predictable)

### Error Handling
- Never throw - return errors in result object
- Include original error codes (ENOENT, EACCES)
- Add context about what operation was attempted
- Preserve stack traces for debugging

### Path Resolution
- All paths must be absolute (validated by parser)
- No path traversal validation (security is out of scope for v1)
- Symlinks followed transparently

### Directory Operations
- `dir_delete` only removes empty directories
- No recursive deletion option (safety)
- `ls` returns flat listing with type info

### Search Operations
- `grep` uses simple substring matching
- Include patterns use glob syntax
- Results include line numbers
- Large file handling: streaming for files >10MB

## Performance Considerations

- File operations are synchronous from caller perspective
- No caching of file contents
- No watch/monitor capabilities
- Each operation is independent

## Encoding

- All text files assumed UTF-8
- Binary files not supported in v1
- Line endings preserved as-is

## Limits

- Max file size: 10MB (from unified-design.yaml)
- No limit on number of operations
- No timeout on individual operations

## Test Conventions

- Test files use `/tmp/t_{test-name}/` path pattern for isolation
- Each test creates its own subdirectory to avoid conflicts
- Integration tests track created paths for cleanup

## Future Considerations

- Batch operations for efficiency
- Binary file support
- File watching/monitoring
- Atomic write operations (write to temp, rename)
- Path validation against allowlist


# fs-ops ARCH.md - Additional Sections

## File Move Behavior

### Overwrite Semantics
- `file_move` overwrites existing destination files without warning
- Matches Unix `mv` behavior and Node.js `rename()` semantics  
- Rationale: LLM can check first if needed, but overwrite-by-default enables single-shot operations
- Return data includes `overwrote: true` when destination existed

### Directory Creation
- `file_move` automatically creates parent directories for destination path
- Diverges from standard `rename()` which fails with ENOENT
- Rationale: Reduces LLM round-trips for common "move to new location" pattern

## Error Message Enhancement

### Problem: Ambiguous ENOENT
Node.js returns ENOENT for multiple distinct failures:
- Source file doesn't exist
- Destination directory doesn't exist  
- Parent directory permissions (sometimes)

### Solution: Pre-flight Checks
Operations perform checks before system calls to provide specific errors:
- `file_move`: Check source exists → "Source file not found" vs generic ENOENT
- `file_write`: Already creates parent dirs, avoiding ambiguity
- `file_delete`: Pass through Node errors (unambiguous)

### Error Format
When enhancing errors for LLM clarity:
```
{operation}: {specific_issue} '{path}' ({error_code})
```

Example: `file_move: Source file not found '/tmp/ghost.txt' (ENOENT)`
=== END FILE: /Users/stuart/repos/clada/proj/comp/fs-ops/doc/ARCH.md ===

